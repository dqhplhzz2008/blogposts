---
ID: 3695
post_title: >
  Java语言程序设计【学堂在线】（第五章）整理
post_name: 'java%e8%af%ad%e8%a8%80%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e3%80%90%e5%ad%a6%e5%a0%82%e5%9c%a8%e7%ba%bf%e3%80%91%ef%bc%88%e7%ac%ac%e4%ba%94%e7%ab%a0%ef%bc%89%e6%95%b4%e7%90%86'
author: 小奥
post_date: 2018-03-19 17:58:01
layout: post
link: >
  http://www.yushuai.me/2018/03/19/3695.html
published: true
tags:
  - Java
categories:
  - Java
---
<h1><span style="font-weight:normal">第五章 输入输出</span></h1><h2><span style="font-weight:normal">5.1 </span><span style="font-weight:normal">异常处理</span></h2><h3><span style="font-weight:normal">5.1.1 </span><span style="font-weight:normal">异常处理的概念</span></h3><p style="text-indent:28px">异常处理：异常又称例外，是特殊的运行错误对象。它是一种程序容错机制，当程序运行时，遇到用户或环境的错误时，程序要有能力处理这些错误，并从错误中恢复出来并执行。如果无法恢复，则应该给予一些错误提示。</p><p style="text-indent:28px">Java中声明了很多异常类，每个异常类都代表一种运行错误，类中包含了该运行错误的信息和处理错误的方法。</p><p style="text-indent:28px">每当Java程序运行过程中发生一个可识别的运行错误（Java中有一个与之对应的类）时，即该错误有一个异常类与之相对应时，系统都会产生一个相应的异常类对象，即产生一个异常。</p><p style="text-indent:28px">当遇到异常时，应该怎么做：</p><p style="text-indent:28px">（1）不处理异常。但是需要声明一下，将异常抛给环境，也就是JVM，Java虚拟机。</p><p style="text-indent:28px">（2）处理异常。</p><p style="text-indent:28px">Java异常处理机制的优点：</p><p style="text-indent:28px">（1）将错误处理代码从常规代码分离出来；</p><p style="text-indent:28px">（2）按错误类型和差别分组；</p><p style="text-indent:28px">（3）对无法预测的错误的捕获和处理；</p><p style="text-indent:28px">（4）克服了传统方法的错误信息有限的问题；</p><p style="text-indent:28px">（5）把错误传播给调用堆栈。</p><p style="text-indent:28px">错误分类：一类叫做错误，是致命性的，程序无法处理，Error类是所有错误类的超类；另外一类是异常，非致命性的，可编程捕获和处理，Exception类是所有异常类的超类。</p><p style="text-indent:28px">异常分为非检查型异常和检查型异常。对于非检查型异常来说：</p><p style="text-indent:28px">（1）不期望程序捕获的异常，在方法中不需要声明，编译器也不进行检查；</p><p style="text-indent:28px">（2）继承自RuntimeException；</p><p style="text-indent:28px">（3）不要求捕获和声明的原因：引发RuntimeException的操作在Java应用程序中会频繁出现；</p><p style="text-indent:28px">（4）它表示的问题不一定作为异常处理。如在除法运算时检查0值，而不适用ArithmeticException。可以在使用引用前测试控制。</p><p style="text-indent:28px">对于检查型异常来说，它是其他类型的异常。如果被调用方法抛出一个类型为E的检查型异常，那么调用者必须捕获或者声明抛出E（或者E的父类），编译器是要检查的。</p><p style="text-indent:28px">Java预定义的一些常见异常如图1所示。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180319/1521453442118600.jpg" title="1521453442118600.jpg" alt="1521453442118600.jpg" width="439" height="287"/>&nbsp;</p><p style="text-align:center">图1</p><h3><span style="font-weight:normal">5.1.2 </span><span style="font-weight:normal">异常的处理</span></h3><p>1.检查型异常的处理</p><p style="text-indent:28px">（1）声明抛出异常。不在当前方法内处理异常，使用throws子句声明将异常抛出到调用方法中；如果所有的方法都选择抛出此异常，最后JVM将捕获它，输出相关错误信息并终止程序运行。</p><p style="text-indent:28px">（2）捕获异常。使用try{}catch{}捕获异常进行处理。</p><p style="text-indent:28px">如图2所示，这是一个异常处理示意图。</p><p style="text-indent:28px">方法一调用方法2，然后方法2调用方法3，方法是调用方法4，如果在方法4中探测异常发生，那么方法4选择抛出异常，就会沿着调用栈方向向上抛出，也就是说抛给方法3，然后2，然后1，如果方法1打算处理异常，那就应该捕获异常处理。</p><p style="text-indent: 0em; text-align: center;">&nbsp;<img src="/wp-content/uploads/image/20180319/1521453467534957.jpg" title="1521453467534957.jpg" alt="1521453467534957.jpg" width="439" height="203"/></p><p style="text-align:center">图2</p><p><strong>例：抛出异常</strong></p><p>代码：</p><pre class="brush:java;toolbar:false">public&nbsp;void&nbsp;openThisFile(String&nbsp;fileName)
throws&nbsp;java.io.FileNotFoundException{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//code&nbsp;for&nbsp;method
}
public&nbsp;void&nbsp;getCustomerInfo()
throws&nbsp;java.io.FileNotFoundException{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//do&nbsp;something
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.openThisFile(&quot;customer.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//do&nbsp;something
}</pre><p>如果在openThisFile中抛出了FileNotfoundException异常，getCustomerInfo将停止执行，并将此异常传送给它的调用者。</p><p>关于捕获异常的语法，见图3所示。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180319/1521453410155847.jpg" title="1521453410155847.jpg" alt="1521453410155847.jpg" width="439" height="256"/>&nbsp;</p><p style="text-align:center">图3</p><p>2.生成异常对象：</p><p style="text-indent:28px">三种方式：由Java虚拟机生成；Java类库中某些类生成；自己写的程序中生成和抛出异常对象。</p><p style="text-indent:28px">抛出异常对象都是通过throw语句实现，异常对象必须是Throwable或者其子类的实例。</p><p><strong>例：生成异常对象</strong></p><p>代码：</p><pre class="brush:java;toolbar:false">class&nbsp;ThrowTest{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ArithmeticException();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(ArithmeticException&nbsp;ae){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(ae);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ArrayIndexOutOfBoundsException();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(ArrayIndexOutOfBoundsException&nbsp;ai){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(ai);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;StringIndexOutOfBoundsException();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(StringIndexOutOfBoundsException&nbsp;si){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(si);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>3.声明自己的异常类</p><p style="text-indent:14px">自定义的所有异常类必须是Exception的子类。</p><p style="text-indent:14px">声明语法如下：</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyExceptionName&nbsp;extend&nbsp;SuperclassOfMyException{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MyExceptionName(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(&quot;Some&nbsp;string&nbsp;explaining&nbsp;the&nbsp;exception&quot;);
//继承的这个超类，可以是Exception也可以是Exception的子类
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><h2><span style="font-weight:normal">5.2 </span><span style="font-weight:normal">输入输出流</span></h2><p>1.输入流和输出流</p><p style="text-indent:28px">输入流是程序从空间之外的别的地方流入程序空间里面；输出流是反过来，将程序空间中的数据送到程序空间之外的地方。</p><p>预定义的I/O类：</p><p>&nbsp;&nbsp;&nbsp; 从流的方向分为：输入流和输出流。</p><p style="text-indent:28px">从流的分工划分：节点流（真正的去访问文件，输入输出操作的流）和处理流（在节点流之上对信息进行加工处理转换）。</p><p style="text-indent:28px">从流的内容：面向字符的流（字符数据）；面向字节的流（一般目的）。</p><p style="text-indent:28px">面向字符的流：源或目标通常是文本文件；能够实现内部格式和文本文件中的外部格式之间转换；内部格式是16位，外部是utf格式，包括ascii等。</p><p>2.面向字符的抽象流类——Reader和Writer</p><p style="text-indent:28px">java.io包中所有字符流的抽象超类。Reader提供了输入字符的API，Writer提供了输出字符的API。它们的子类又分为两大类：节点流和处理流。</p><p style="text-indent:28px">多数程序使用这两个抽象类的一系列子类来读入/写出文本信息。例如FileReader/FileWriter用来读写文本文件。</p><p style="text-indent:28px">面向字符的流如图4所示，阴影部分为节点流，其它为处理流。</p><p style="text-align: center; text-indent: 0em;"><img src="/wp-content/uploads/image/20180319/1521453381127861.jpg" title="1521453381127861.jpg" alt="1521453381127861.jpg" width="439" height="302"/>&nbsp;</p><p style="text-align:center">图4</p><h2><span style="font-weight:normal">5.3 </span><span style="font-weight:normal">文件读写</span></h2><h3><span style="font-weight:normal">5.3.1 </span><span style="font-weight:normal">写文本文件</span></h3><p style="text-indent:28px">为了在磁盘上创建一个文本文件并往其中写入字符数据，需要使用到FileWriter类，它是OutputStreamWriter类的子类，而后者又是Writer类的子类。</p><p><strong>例：创建文件并写入若干行文本</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
class&nbsp;FileWriterTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;IOException{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//main方法中声明抛出IO异常
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;fileName&nbsp;=&nbsp;&quot;Hello.txt&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileWriter&nbsp;writer&nbsp;=&nbsp;new&nbsp;FileWriter(fileName);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write(&quot;Hello\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write(&quot;This&nbsp;is&nbsp;my&nbsp;first&nbsp;text&nbsp;file.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.close()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">我们发现在利用\n换行的时候并不能达到我们想要的效果，这是因为\n在不同平台下效果不一样。我们还发现，每一次运行都是删除原有的文件，重新再创建一个文件，根本不询问也不判断。</p><p><strong>例：写入文本文件，并处理IO异常</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
class&nbsp;FileWriterTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//main方法中声明抛出IO异常
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;fileName&nbsp;=&nbsp;&quot;Hello.txt&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将所有IO操作放入try块中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileWriter&nbsp;writer&nbsp;=&nbsp;new&nbsp;FileWriter(fileName,true);
//true表示是追加而不是覆盖
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write(&quot;Hello\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write(&quot;This&nbsp;is&nbsp;my&nbsp;first&nbsp;text&nbsp;file.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.close()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException&nbsp;iox){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//若出错则屏幕提示
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Problem&nbsp;Writing&quot;&nbsp;+&nbsp;fileName);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><strong>说明：</strong></p><p style="text-indent:28px">运行此程序，会发现源文件内容后面又追加了第二个程序的内容，这是将构造方法第二个参数设置为true的效果。</p><p style="text-indent:28px">如果将文件属性改为只读属性，再运行本程序，就会出现IO错误，程序将转入catch块中，给出错误信息。</p><p><strong>BufferedWriter类</strong></p><p style="text-indent:28px">FileWriter和BufferedWriter类都用于输出字符流，包含的方法几乎完全一样，但后者多提供了一个newLine()方法用于换行。<strong><span style="color:red">这个方法可以跨平台</span></strong>。</p><p><strong>例：写入文本文件，使用BufferedWriter</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
class&nbsp;BufferedWriterTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;IOException{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//main方法中声明抛出IO异常
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;fileName&nbsp;=&nbsp;&quot;Hello.txt&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedWriter&nbsp;out&nbsp;=&nbsp;new&nbsp;BufferedWriter(new&nbsp;FileWriter(fileName));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.write(&quot;Hello&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.newLine();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write(&quot;This&nbsp;is&nbsp;my&nbsp;first&nbsp;text&nbsp;file.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.newLine();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.close()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><h3><span style="font-weight:normal">5.3.2 </span><span style="font-weight:normal">读文本文件</span></h3><p style="text-indent:28px">从文本文件读字符数据需要使用FileReader类，由图4可以看出它继承Reader抽象类的子类InputStreamReader。对应于写文本文件的缓冲器，读文本文件也有缓冲器BufferedReader，具有readLine()函数，可以对换行符进行识别，一行一行地读取输入流中的内容。</p><p><strong>例：读取Hello.txt文本并显示在屏幕上</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
class&nbsp;BufferedReaderTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;IOException{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//main方法中声明抛出IO异常
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;fileName&nbsp;=&nbsp;&quot;D:/Hello.txt&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;line;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader&nbsp;in&nbsp;=&nbsp;new&nbsp;BufferedReader(new&nbsp;FileReader(fileName));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;&nbsp;=&nbsp;in.readLine();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(line&nbsp;!&nbsp;=&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(line);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;=&nbsp;in.readLine();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException&nbsp;iox){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.ourt.println(&quot;Problem&nbsp;reading.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">还有一种判断文本文件结尾的方法，那就是利用Reader类的read()方法返回的一个int型整数。如果读到文件末尾，该方法返回-1.因此，可以将上例中读文件判断部分改为：</p><pre class="brush:java;toolbar:false">int&nbsp;c;
while((c&nbsp;=&nbsp;in.read())!=-1)
System.out.println((char)c);</pre><p style="text-indent:28px">关闭输入流文件并不像关闭输出流文件那么重要，因为当检测到文件结尾时输入流中就没有数据了，因而没有必要去刷新它。</p><h3><span style="font-weight:normal">5.3.3 </span><span style="font-weight:normal">写二进制文件</span></h3><p style="text-indent:28px">Java.io包中的OutputStream及其子类专门用于写二进制数据。FileOutputStream是其子类，可用于将二进制数据写入文件，用于一般目的输出（非字符数出），用于成组字节输出此方法的二进制文件的数据可以被运行在任何平台上的Java程序正确读取。DataOutputStream是OutputStream的另一子类，它可以链接到一个FileOutputStream上，便于写各种基本类型的数据。</p><p style="text-indent:28px">DataOutputStream类的成员如图5，图6所示。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180319/1521453304615295.jpg" title="1521453304615295.jpg" alt="1521453304615295.jpg" width="439" height="274"/></p><p style="text-align:center">图5</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180319/1521453290965252.jpg" title="1521453290965252.jpg" alt="1521453290965252.jpg" width="439" height="258"/>&nbsp;</p><p style="text-align:center">图6</p><p><strong>例：将int写入文件</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
class&nbsp;FileOutputStreamTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;fileName&nbsp;=&nbsp;&quot;myData.dat&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value0&nbsp;=&nbsp;255,&nbsp;value1&nbsp;=0,&nbsp;value2&nbsp;=&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream&nbsp;out&nbsp;=&nbsp;new&nbsp;DataOutputStream
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new&nbsp;FileOutputStream(fileName));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将FileOutputStream与DataOutputStream连接可
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//输出不同类型数据
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.writeInt(value0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.writeInt(value1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.writeInt(value2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException&nbsp;iox){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Problem&nbsp;writing&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><strong>BufferedOutputStream类</strong></p><p>用法示例：</p><p>DataOutputStream out = new DataOutputStream(new</p><p style="text-indent:84px">BufferedOutputStream((new FileOutputStream(filename)));</p><p><strong>例：向文件写一个字节并读取</strong></p><p style="text-indent:28px">向文件中写入内容为-1的一个字节，并读取出来。</p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
public&nbsp;class&nbsp;FileOutputStreamTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream&nbsp;out&nbsp;=&nbsp;new&nbsp;DataOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;FileOutputStream(&quot;trytry.dat&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.writeByte(-1);out.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream&nbsp;in&nbsp;=&nbsp;new&nbsp;DataInputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;FileInputStream(&quot;trytry.dat&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;in.readByte();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Integer.toHexString(a));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in.skip(-1);//往后一个位置，以便下面重新读出
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=.in.readUnsignedByte();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Integer.toHexString(a));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>运行结果：</p><p>ffffffff &nbsp;&nbsp;-1&nbsp;&nbsp; ff&nbsp;&nbsp; 255</p><h3><span style="font-weight:normal">5.3.4 </span><span style="font-weight:normal">读二进制文件</span></h3><p style="text-indent:28px">读二进制文件，比较常用的类有FileInputStream,DataInputStream,BufferedInputStream等。DataInputStream也提供了很多方法用于读入布尔型、字节、字符、整型、长整型、短整型、单精度、双精度等数据。</p><p><strong>例：读取二进制文件中的3个int型数字并相加</strong></p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180319/1521453258239267.jpg" title="1521453258239267.jpg" alt="1521453258239267.jpg" width="439" height="204"/></p><p style="text-align:center">图7</p><p><strong>例：通过捕获异常控制读取结束</strong></p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180319/1521453234842945.jpg" title="1521453234842945.jpg" alt="1521453234842945.jpg" width="439" height="215"/></p><p style="text-align:center">图8</p><p style="text-indent:28px">第二个try就一直在读，直到读结束了，while循环结束，然后出来，直接到了第一个catch这里，去执行这里面的操作。</p><p style="text-indent:28px">之所以外面还有一层try…catch操作，就是为了对其它的IOEXCEPTION做准备。</p><p><strong>例：用字节流读取文本文件</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
public&nbsp;class&nbsp;InputStreamTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream&nbsp;s&nbsp;=new&nbsp;FileInputStream(&quot;Hello.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;c;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((c&nbsp;=&nbsp;s.read())!=1)//读取1字节，结果返回-1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.write(c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><strong>说明：</strong></p><p style="text-indent:28px">read()方法读取一个字节，转化为[0,255]的之间的一个整数，返回一个Int。如果读到了文件末尾，则返回-1.</p><p style="text-indent:28px">wirte(int)方法写一个字节的低8位，忽略高24位。</p><h3><span style="font-weight:normal">5.3.5 FILE</span><span style="font-weight:normal">类</span></h3><p>FILE类的作用：</p><p>（1）创建、删除文件；（2）重命名文件；（3）判断文件的读写权限以及是否存在；（4）设置和查询文件的最近修改时间等；（5）构造文件流时使用FILE类作为参数。</p><p><strong>例：FILE类举例</strong></p><p>创建文件Hello.txt，如果存在则删除旧文件，不存在则直接创建新的。</p><p><strong>代码：</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
public&nbsp;class&nbsp;FileTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;f&nbsp;=&nbsp;new&nbsp;File(&quot;Hello.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f.exists())&nbsp;f.delete();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.createNewFile();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(Exception&nbsp;e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(e.getMessage());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><strong>运行结果：</strong></p><p style="text-indent:28px">因为在前面的例子中已经创建Hello.txt，所以第一次运行将删除这个文件；第二次运行则又创建了一个此名的空文件。</p><p><strong>分析：</strong></p><p style="text-indent:28px">在试图打开文件之前，可以使用File两类的isFile方法来确定File对象是否代表一个文件而非目录。</p><p style="text-indent:28px">还可以通过exists方法判断同名文件或者路径是否存在，进而采取正确的方法，避免造成误操作。</p><p><strong>例：改进的文件复制程序</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
public&nbsp;class&nbsp;NewCopyBytes{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream&nbsp;instr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream&nbsp;outstr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(args.length&nbsp;!=&nbsp;2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Please&nbsp;Enter&nbsp;file&nbsp;names!&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;inFile&nbsp;=&nbsp;new&nbsp;File(args[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;outFile&nbsp;=&nbsp;new&nbsp;File(args[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(outFile.exists()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(args[1]+&quot;already&nbsp;exists.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!inFile.exists()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(args[0]&nbsp;+&nbsp;&quot;does&nbsp;not&nbsp;exist.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instr&nbsp;=&nbsp;new&nbsp;DataInputStream(new&nbsp;BufferedInputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;FileInputStream(inFile)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outstr&nbsp;=&nbsp;new&nbsp;DataOutputStream(new&nbsp;BufferedOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;FileOutputStream(outFile)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;instr.readUnsignedByte();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outstr.writeByte(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(EOFException&nbsp;eof){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outstr.close();instr.close();return;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch&nbsp;(FileNotFoundException&nbsp;nfx){/*代码不再写*/}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException&nbsp;ios){/*代码不再写出*/}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><h3><span style="font-weight:normal">5.3.6 </span><span style="font-weight:normal">处理压缩文件</span></h3><p style="text-indent:28px">java.util.zip包中提供了一些类可以压缩格式对流进行读写。它们都继承自字节流类OutputStream和InputStream。其中GZIPOutputStream和ZipOutputStream可分别把数据压缩成GZIP和zip格式，GZIPInputStream和ZipInputStream可以分别把压缩成GZIP和ZIP格式的数据解压缩恢复原状。</p><p><strong>例：压缩和解压缩Gzip文件</strong></p><p style="text-indent:28px">将文本文件Hello.txt压缩为文件test.gz，再解压缩该文件，显示其中内容，并另存为newHello.txt。</p><p>代码见图9、图10所示。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180319/1521453198896115.jpg" title="1521453198896115.jpg" alt="1521453198896115.jpg" width="439" height="185"/></p><p style="text-align:center">图9</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180319/1521453176115191.jpg" title="1521453176115191.jpg" alt="1521453176115191.jpg" width="439" height="163"/>&nbsp;</p><p style="text-align:center">图10</p><p style="text-indent:28px">图9首先是创建一个文件流对象in，然后创建一个对象out，它是在文件流外侧套一个GZIPOutputStream，这便是创建了压缩文件“test.gz”。然后就是和前面复制文件一样了，先读出hello.txt文件的内容，然后再写入gz文件中。</p><p style="text-indent:28px">在图10中，是一个解压缩过程。构造输入流，也是在输入流最底下原声字节输入流外面接一个解压缩输入流，经过这个解压缩的输入流就可以自然的把从压缩文件中读出的数据恢复成普通的解压缩后的数据了。然后接下来我们指导它是一个文本文件，又希望我们最后把它恢复到一个文本文件，所以我们还得用读文本文件的方式去按行读，解压缩以后它还是一个二进制流，所以我们就要用InputStreamReader，它是面向字节的流和面向字符的流之间的一个桥梁，经过它以后再经过一个BufferedReader那么我们就可以按行读了，所以在while中按行读，读一行在显示器显示一行。显示完关闭一行。接下来我们依然可以用刚才的方式，按行读取文本。由于仅仅是要解压缩并且把解压缩的结果写到新闻界去，我们也可以不管它是不是文本文件就简单解压缩就可以了，所以就只在FileInputStream外面套了一个GZIPInputStream这个解压缩的输入流，然后就用另外的复制文件方法那样一步一步完成复制。最后关闭。</p><p><strong>运行结果：</strong></p><p style="text-indent:28px">首先生成了压缩文件“test.gz”，再读取显示其中的内容，和”Hello.txt”中的内容完全一样；再解压缩文件“newHello.txt”，和“Hello.txt”中的内容也完全相同。</p><p>例：Zip文件的压缩与解压缩</p><p>代码：</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180319/1521453161114720.jpg" title="1521453161114720.jpg" alt="1521453161114720.jpg" width="439" height="233"/>&nbsp;</p><p style="text-align:center">图11</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180319/1521453148194665.jpg" title="1521453148194665.jpg" alt="1521453148194665.jpg" width="439" height="219"/></p><p style="text-align:center">图12</p><p style="text-indent:28px">操作文件的是这个FileOutputStream二进制流，然后套了一个缓冲的流，最外层是ZIP的流。压缩多个文件，就要有多个文件之间的间隔。首先用for循环依次去打开不同的输入文件，所以在每一轮我们取一个命令行参数作为名来作为输入流，然后在压缩每个文件前首先将zipentry这个文件开始标记写到文件中去。所以用压缩源来源文件名做参数，构造一个zipentry，写进去。接下来就是read和write操作。然后关闭输入流。再循环，循环后结束，关闭输出流。</p><p style="text-align:center;text-indent:28px"><img src="/wp-content/uploads/image/20180319/1521453132106593.jpg" title="1521453132106593.jpg" alt="1521453132106593.jpg" width="439" height="314"/>&nbsp;</p><p style="text-align:center;text-indent:28px">图13</p><p style="text-indent:28px">接下来的部分是解压缩。利用一个ZipInputStream用来解压缩，也是在普通的二进制流和缓冲流基础上加一个解压缩流。每次外层循环判断还有文件不，在内层循环中解压缩，然后往显示器上写。等外层循环完了，关闭所有的流。</p><p><strong>运行结果：</strong></p><p style="text-indent:28px">在命令行输入两个文本文件名后，将生成test.zip文件；在屏幕上显示解压后每个文件的内容；在资源管理器窗口，可以使用winzip软件解压缩该文件，恢复出和原来文件相同的两个文本文件。</p><p><strong>例：解压缩zip文件，并恢复原来的路径</strong></p><p>具体代码见课本</p><h3><span style="font-weight:normal">5.3.7 </span><span style="font-weight:normal">对象序列化</span></h3><p style="text-indent:28px">需要将程序编写时的一些数据永久保存，那么就要对对象进行序列化，即按照整体写到文件中，再整体读出来。</p><p><strong>ObjectInputStream/ObjectOutStream类</strong></p><p>1.实现对象的读写：通过前者把对象读入程序；通过后者把对象写入磁盘文件。</p><p><strong><span style="color:#2F5597">注意：transient和static类型的变量不会被保存。对象要想实现序列化，其所属类必须实现serializable接口。</span></strong></p><p>2.实现方法：</p><p>OBjectOutputStream</p><p>必须通过另一个流构造ObjectOutputStream：</p><pre class="brush:java;toolbar:false">FileOutputStream&nbsp;out&nbsp;=&nbsp;new&nbsp;FileOutputStream(“theTime”);
ObjectOutputStream&nbsp;s&nbsp;=&nbsp;new&nbsp;ObjectOutputStream(out);
s.writeObject(“Today”);
s.writeObject(new&nbsp;Date());
s.flush();</pre><p>&nbsp;</p><p>&nbsp;</p><p>ObjectInputStream:</p><p>必须通过另一个流构造ObjectInputStream：</p><pre class="brush:java;toolbar:false">FileInputStream&nbsp;in&nbsp;=&nbsp;new&nbsp;FileInputStream(“theTime”);
ObjectInputStream&nbsp;s&nbsp;=&nbsp;new&nbsp;ObjectInputStream(out);
String&nbsp;today&nbsp;=&nbsp;(String)s.readObject();
Date&nbsp;date&nbsp;=&nbsp;(Date)s.readObject();</pre><p>&nbsp;</p><p>3.Seriealizable</p><p>Seriealizable的定义</p><pre class="brush:java;toolbar:false">package&nbsp;java.io;
public&nbsp;interface&nbsp;Serializable{
//there’s&nbsp;nothing&nbsp;in&nbsp;here!};</pre><p>这是一个典型的代码。实现接口的语句：</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyClass&nbsp;implements&nbsp;Serializable&nbsp;{/*程序体*/}</pre><p><strong><span style="color:red">使用关键字transient可以阻止对象的某些成员被自动写入文件。</span></strong></p><p><strong>例：创建一个书籍对象输出并读出</strong></p><p style="text-indent:28px">创建一个书记对象，并把它输出到一个文件book.dat中，然后再把该对象读出来，在屏幕上显示对象信息。</p><p><strong>程序代码：</strong></p><pre class="brush:java;toolbar:false">import&nbsp;java.io.*;
&nbsp;
public&nbsp;class&nbsp;SerializableTester{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;throws&nbsp;IOException,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassNotFoundException{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//新建一个Book类的对象
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Book&nbsp;book&nbsp;=&nbsp;new&nbsp;Book(100032,&nbsp;&quot;Java&quot;,&nbsp;&quot;Wang&quot;,30);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream&nbsp;oos&nbsp;=new&nbsp;ObjectOutputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;FileOutputStream(&quot;book.dat&quot;));//创建一对象输出流
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oos.writeObject(book);//向流中写对象
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oos.close();//关闭输出流
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;book&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream&nbsp;ois&nbsp;=&nbsp;new&nbsp;ObjectInputStream(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;FileInputStream(&quot;book.dat&quot;));//创建一对象输入流
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;book=&nbsp;(Book)&nbsp;ois.readObject();//读入对象并强制转型为BOOK类
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ois.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ID&nbsp;is&quot;&nbsp;+&nbsp;book.id);//读取对象信息并显示
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//剩余输出信息不再累述
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;
class&nbsp;Book&nbsp;implements&nbsp;Serializable{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;author;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;price;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Book(int&nbsp;id,&nbsp;String&nbsp;name,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;author,&nbsp;float&nbsp;price){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id&nbsp;=id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.author&nbsp;=&nbsp;author;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.price&nbsp;=&nbsp;price;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">如果希望增加Book类的功能，使其还能够具有借书方法borrowBook，并保存借书人的借书号borrowID，课对BOOK类添加如下内容：</p><pre class="brush:java;toolbar:false">transient&nbsp;int&nbsp;borrowerID;
public&nbsp;void&nbsp;borrowBook(int&nbsp;ID){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thi.borrowerID&nbsp;=&nbsp;ID;
}
//在main方法中创建了Book类的一个对象后，紧接着调用此方法，输入ID为2018：
book.borrowBook(2018);
//最后再要求从读入的对象中输出borrowerID
System.out.println(book.borrowerID);</pre><p>&nbsp;&nbsp;&nbsp; 可以发现borrowID为0，这是因为声明为transient了，所以保存和读出对象时都不会进行处理，如果去掉transient关键字，则可以正确读出2018。</p><p>&nbsp;</p><h3><span style="font-weight:normal">5.3.8 </span><span style="font-weight:normal">随机文件读写</span></h3><p>RandomAccessFile类</p><p>（1）可跳转到文件的任意位置读写数据；</p><p>（2）课在随机文件中插入数据，而不破坏该文件的其它数据。</p><p><strong>注意：所有的位置这些东西都需要自己计算。</strong></p><p>（3）实现了DataInput和DataOutput接口，可使用普通的读写方法；</p><p>（4）有个位置指示器，指向当前读写处的位置。刚打开文件时，文件指示器指向文件的开头出。对文件指针显式操作的方法有：</p><p>int skipBytes(int n)：把文件指针向前移动指定的n个字节；</p><p>void seek(long)：移动文件指针到指定的位置；</p><p>long getFilePointer()：得到当前的文件指针。</p><p>（5）在等长记录格式文件的随机读取时有很大的优势，但仅限于操作文件，不能访问其它IO设备，如网络、内存映像等。</p><p>（6）构造方法：</p><pre class="brush:java;toolbar:false">public&nbsp;RandomAccessFile(File&nbsp;file,&nbsp;String&nbsp;mode)&nbsp;throws&nbsp;FileNotFoundException
public&nbsp;RandomAccessFile(String&nbsp;name,&nbsp;String&nbsp;mode)&nbsp;throws&nbsp;FileNotFoundException</pre><p>（7）构造对象时，应指出操作：仅读，还是读写。</p><pre class="brush:java;toolbar:false">new&nbsp;RandomAccessFile(“farrago.txt”,&nbsp;“r”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new&nbsp;RandomAccessFile(“farrago.txt”,&nbsp;“rw”);</pre><p><strong><span style="color:red">要实现随机读写，文件的记录必须是等长的！</span></strong></p>
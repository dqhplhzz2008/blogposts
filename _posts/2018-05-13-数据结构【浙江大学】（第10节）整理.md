---
ID: 3789
post_title: >
  数据结构【浙江大学】（第10节）整理
post_name: '%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e3%80%90%e6%b5%99%e6%b1%9f%e5%a4%a7%e5%ad%a6%e3%80%91%ef%bc%88%e7%ac%ac10%e8%8a%82%ef%bc%89%e6%95%b4%e7%90%86'
author: 小奥
post_date: 2018-05-13 21:29:44
layout: post
link: >
  http://www.yushuai.me/2018/05/13/3789.html
published: true
tags:
  - 数据结构
categories:
  - Data Structure
---
<h1>第十讲：排序（下）</h1><h2>10.1 快速排序</h2><h3>10.1.1 算法概述</h3><p style="text-indent:28px">策略：分而治之。</p><p style="text-indent:28px">下面举个例子，假如一组数为13/81/92/43/65/31/57/26/75/0，我们对其进行排序。那么首先选择出一个主元，这里我们选择为65，那么将这组数的其他成员分为了两组，一组是小于主元的13/43/31/57/26/0，一组是大于主元的81/92/75.然后将其递归处理，两边各选一个主元再进行分组……倒数第二步的时候，我们在第一步选择出来的主元左侧已经排好了顺序，右侧也排好了顺序，这样将它们放在同一个数组中，就完成了排序。</p><p style="text-indent:28px">以下是上面这段话的伪码描述：</p><pre class="brush:cpp;toolbar:false">void&nbsp;QuickSort(ElementType&nbsp;A[],&nbsp;int&nbsp;N)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(N&lt;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pivot&nbsp;=&nbsp;从A[]中选一个主元;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将S={A[]\PIVOT}分成2个独立子集：
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A1={a∈S|a≤piovt}和
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A2={a∈S|a≥piovt}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[]=Quic_Sort(A1,N1)∪(pivot)∪QuickSort(A2,N2);
}</pre><p style="text-indent:28px">这个方法的关键在于<strong><span style="color:red">主元的选取</span></strong>（选取不好，快速算法会很慢）和<strong><span style="color:red">子集划分</span></strong>（这个过程也是耗费时间的一个地方）。</p><p style="text-indent:28px">快速排序算法的最好情况就是<strong>每次正好中分</strong>，<strong>T(N)=O(NlogN)</strong>。</p><h3>10.1.2 选主元</h3><p style="text-indent:28px">选取头、中、尾的中位数，也可以选取5个、7个等数字的中位数。例如8/12/3的中位数就是8。伪码描述如下：</p><pre class="brush:cpp;toolbar:false">ElementType&nbsp;Median3(ElementType&nbsp;A[],&nbsp;int&nbsp;Left,&nbsp;int&nbsp;Right)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Center=(Left+Right)/2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(A[Left]&gt;A[Center])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(&amp;A[Left],&amp;A[Center]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(A[Left]&gt;A[Right])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(&amp;A[Left],&amp;A[Right]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(A[Center]&gt;A[Right])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(&amp;A[Center],&amp;A[Right]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(&amp;A[Center],&amp;A[Right-1]);/*将pivot藏到右边*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*只需要考虑A[left+1]到A[Right-2]，这样来划分左右*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;A[Right-1];
}</pre><h3>10.1.3 子集划分</h3><p style="text-indent:28px">为了便于理解，还是举一个例子：</p><table width="100"><tbody><tr class="firstRow"><td width="10" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p>8</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>1</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>4</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>9</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>0</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>3</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>5</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>2</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>7</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:red">6</span><span style="color:red">（M）</span></strong></p></td></tr></tbody></table><p style="text-indent:28px">定义两个指针i（指向第一个元素）和j（指向中位数左侧的元素）。（<strong>继续强调，这里的i和j不是实际的指针，而是存储所需要元素下标的整数。</strong>）先比较i代表的元素和主元的大小，发现8大于6，那么i这个指针不变；然后看j代表的元素和主元比较，发现7大于6，将j减一（即左移一位），然后再比较，发现2小于6，这样就不对了，j停止移动。在i和j都停止移动后，将其所指向的两个元素交换位置，变成了下面这个样子。</p><table width="100"><tbody><tr class="firstRow"><td width="10" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#7030A0">2</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>1</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>4</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>9</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>0</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>3</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>5</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#7030A0">8</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>7</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:red">6</span><span style="color:red">（M）</span></strong></p></td></tr></tbody></table><p style="text-indent:28px">然后i加1（右移一位），1小于6，正常，i继续加1（右移一位），4小于6，正常，i继续加1（右移一位），此时9大于6，不正常，i停止；再看j减1（左移一位），5小于6，不正常，j停止，然后交换此时i和j所代表的元素，变成下面这个样子。</p><table width="100"><tbody><tr class="firstRow"><td width="10" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#7030A0">2</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>1</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>4</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">5</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>0</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>3</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">9</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#7030A0">8</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>7</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:red">6</span><span style="color:red">（M）</span></strong></p></td></tr></tbody></table><p style="text-indent:28px">然后i加1（右移一位），发现正常，i继续加1，发现正常，i再加1，发现9小于6，不正常，i停止；然后j左移一位，发现3小于6，不正常，停止。</p><p style="text-indent:28px">此时发现i-j&lt;0了，子集划分结束，同时将i代表的元素和主元交换，完成了子集的划分。最后结果如下：</p><table width="100"><tbody><tr class="firstRow"><td width="10" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#7030A0">2</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>1</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>4</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">5</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>0</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>3</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:red">6</span><span style="color:red">（M）</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#7030A0">8</span></strong></p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>7</p></td><td width="10" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">9</span></strong></p></td></tr></tbody></table><p style="text-indent:28px">快速算法的“快速”在于，划分完成后其主元被一次性放到了正确的位置再也不会移动；例如插入算法等都需要一步一步往后移。</p><p style="text-indent:28px">如果有元素正好等于pivot怎么办？停下来处理。</p><p style="text-indent:28px">对于小规模数据还不如用插入排序。当递归的数据规模充分小，则停止递归，直接调用简单排序。在程序中定义一个Cutoff的阈值。</p><h3>10.1.4 算法实现</h3><p>&nbsp;&nbsp;&nbsp; 伪码描述：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Quicksort(ElementType&nbsp;A[],&nbsp;int&nbsp;Left,&nbsp;int&nbsp;Right)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Cutoff&lt;=Right-Left)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pivot&nbsp;=&nbsp;Median3(A,&nbsp;Left,&nbsp;Right);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=Left;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j=&nbsp;Right-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(;;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(A[++i]&lt;Pivot){}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(A[--j]&gt;Pivot){}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i&lt;j)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(&amp;A[i],&amp;A[j]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(&amp;A[i],&amp;A[Right-1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quicksort(A,Left,i-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quicksort(A,i+1,Right);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Insertion_Sort(A+Left,Right-Left+1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</pre><p style="text-indent:28px">为了统一接口，在上段程序后面再加一个：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Quick_Sort(ElementType&nbsp;A[],&nbsp;int&nbsp;N)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quicksort(A,&nbsp;0,&nbsp;N-1);
}</pre><p>快速排序算法是<strong><span style="color:red">不稳定</span></strong>算法！</p><p style="text-indent:28px">以下给出另外的C语言编写的代码，它是直接调用函数库：</p><pre class="brush:cpp;toolbar:false">/*&nbsp;快速排序&nbsp;-&nbsp;直接调用库函数&nbsp;*/
&nbsp;
#include&nbsp;&lt;stdlib.h&gt;
&nbsp;
/*---------------简单整数排序--------------------*/
int&nbsp;compare(const&nbsp;void&nbsp;*a,&nbsp;const&nbsp;void&nbsp;*b)
{&nbsp;/*&nbsp;比较两整数。非降序排列&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(*(int*)a&nbsp;-&nbsp;*(int*)b);
}
/*&nbsp;调用接口&nbsp;*/
qsort(A,&nbsp;N,&nbsp;sizeof(int),&nbsp;compare);
/*---------------简单整数排序--------------------*/
&nbsp;
&nbsp;
/*---------------&nbsp;一般情况下，对结构体Node中的某键值key排序&nbsp;---------------*/
struct&nbsp;Node&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;key1,&nbsp;key2;
}&nbsp;A[MAXN];
&nbsp;
int&nbsp;compare2keys(const&nbsp;void&nbsp;*a,&nbsp;const&nbsp;void&nbsp;*b)
{&nbsp;/*&nbsp;比较两种键值：按key1非升序排列；如果key1相等，则按key2非降序排列&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;((const&nbsp;struct&nbsp;Node*)a)-&gt;key1&nbsp;&lt;&nbsp;((const&nbsp;struct&nbsp;Node*)b)-&gt;key1&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(&nbsp;((const&nbsp;struct&nbsp;Node*)a)-&gt;key1&nbsp;&gt;&nbsp;((const&nbsp;struct&nbsp;Node*)b)-&gt;key1&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;如果key1相等&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;((const&nbsp;struct&nbsp;Node*)a)-&gt;key2&nbsp;&lt;&nbsp;((const&nbsp;struct&nbsp;Node*)b)-&gt;key2&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;k;
}
/*&nbsp;调用接口&nbsp;*/
qsort(A,&nbsp;N,&nbsp;sizeof(struct&nbsp;Node),&nbsp;compare2keys);
/*---------------&nbsp;一般情况下，对结构体Node中的某键值key排序&nbsp;---------------*/</pre><h2>10.2 表排序</h2><h3>10.2.1 算法概述</h3><p style="text-indent:28px">表排序用于：元素不是简简单单的排序，每一个元素都是一个庞大的结构，例如一个结构体等，此时如果我们想要交换两个元素，就不能忽略交换所需要的时间了。表排序就是在移动的时候，并不移动原始的数据，只是移动指向它的指针。</p><p style="text-indent:28px">它是一种间接排序的方法，定义一个指针数组作为“表”（table）。</p><p style="text-indent:28px">用下面一个例子来举例：</p><table><tbody><tr class="firstRow"><td width="63" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p>A</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[0]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[1]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[2]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[3]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[4]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[5]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[6]</p></td><td width="59" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[7]</p></td></tr><tr><td width="63" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p>key</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>f</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>d</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>c</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>a</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>g</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>b</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>h</p></td><td width="59" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>e</p></td></tr><tr><td width="63" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p><strong>table</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>0</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>1</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>2</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>3</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>4</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>5</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>6</strong></p></td><td width="59" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>7</strong></p></td></tr></tbody></table><p style="text-indent:28px">利用插入算法，可以得出：</p><table><tbody><tr class="firstRow"><td width="63" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p>A</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[0]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[1]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[2]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[3]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[4]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[5]</p></td><td width="62" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[6]</p></td><td width="59" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>[7]</p></td></tr><tr><td width="63" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p>key</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>f</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>d</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>c</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>a</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>g</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>b</p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>h</p></td><td width="59" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>e</p></td></tr><tr><td width="63" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p><strong>table</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>3</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>5</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>2</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>1</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>7</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>0</strong></p></td><td width="62" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>4</strong></p></td><td width="59" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p><strong>6</strong></p></td></tr></tbody></table><p style="text-indent:28px">如果仅要求按顺序输出，则输出：</p><p>A[table[0]],A[table[1]],……,A[table[N-1]]</p><h3>10.2.2 物理排序</h3><p style="text-indent:28px">所谓物理排序就是说，我们不能像前文那样利用指针来移动，而是必须实际移动结构体，那该怎么办呢？</p><p style="text-indent:28px">利用这样一个原理：<strong>N个数字的排列由若干个独立的环组成</strong>。</p><p style="text-indent:28px">为了解释这个原理，看10.2.1中最后的结果那个表，table[0]值（3）-&gt;table[3]值（1）-&gt;table[1]的值（5）-&gt;table[5](0)返回到了table[0]。一共有三种环，这三种环互不相交，称为独立。</p><p style="text-indent:28px">在排序的时候，先对一个环内进行排序。那么如何判断一个环的结束呢？</p><p><strong>每访问一个空位i后，就令table[i]=i。当发现table[i]==i时，环就结束了。</strong></p><p style="text-indent:28px">下面分析一下复杂度的情况：</p><p style="text-indent:28px">（1）最好的情况：初始即有序。</p><p style="text-indent:28px">（2）最坏的情况：有N/2个环，每个环包含两个元素，元素需要移动3N/2次。</p><p style="text-indent:28px"><strong>但是无论如何，复杂度都可以写为T(N)=O(mN)</strong>，其中m是每个A元素复制需要的时间。</p><h2>10.3 基数排序</h2><h3>10.3.1 桶排序</h3><p style="text-indent:28px">举例：假设我们有N个学生，他们的成绩是0到100之间的整数（于是有于是有M=101个不同的成绩值个不同的成绩值）。如何在线性时间内将学生按成绩排序？</p><p style="text-indent:28px">我们可以为每一个成绩值构造一个“<strong>桶</strong>”，于是就有了101个桶，如图1所示。如果我们有一个88分的学生，那么就把学生的信息查到88分的这个链表的表头里，伪码描述如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Bucket_Sort(ElementType&nbsp;A[],&nbsp;int&nbsp;N)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count[]初始化;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(读入读入11个学生成绩个学生成绩graded)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将该生插入count[grade]链表;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=0;&nbsp;i&lt;M;&nbsp;i++&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(count[i])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出整个count[i]链表;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">时间复杂度：<strong>T(N,M)=O(M+N)</strong></p><p style="text-indent:28px">插入学生的成绩，因为是N个学生，所以复杂度为O(N)；输出成绩，for循环，M个成绩，自然复杂度为O(M)。故总的时间复杂度如上。</p><p style="text-indent:28px">如果有N=40000个学生，由于M=101，故这就是一个线性的复杂度。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180513/1526218142128125.jpg" title="1526218142128125.jpg" alt="1.jpg"/>&nbsp;</p><p style="text-align:center">图1</p><p style="text-indent:28px">但是，如果M&gt;&gt;N怎么办？</p><h3>10.3.2 基数排序</h3><p style="text-indent:28px">举例：假设我们有N=10个整数，每个整数的值在0到999之间之间（于是有于是有M=1000个不同的值个不同的值）。还有可能在线性时间内排序吗？</p><p style="text-indent:28px">这里的基数就是跟进制有关，如果是二进制，基数就是2；如果是十进制，基数就是10。这里我们说的是十进制，所以<strong>基数就是10</strong>。</p><p style="text-indent:28px">加入我们的输入序列为：64,8,216,512,27,729,0,1,343,125，用“次位优先”（Least Significant Digit，LSD）算法。主位是指的第一位，剩余的都叫次位。因此这里比较我们先从个位开始。</p><p style="text-indent:28px">首先我们建立十个“桶”，然后将它们以个位数为标准放到这10个桶里面去，如表中Pass 1；然后按照十位数为标准放到10个桶里，如Pass 2；在完成之后，我们来做一个收集，收集的过程就是扫描每一个桶，然后把桶里的元素按照0,1,8,512,216……顺序用一个链表把它们串起来；串起来后，按照主位放到相应的桶里，如Pass3；最后，再对它们进行一次收集，用链表连起来，得出结果。</p><p style="text-align:center">表3.1 基数排序算法流程表</p><table><tbody><tr class="firstRow"><td width="55" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p>Bucket</p></td><td width="49" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>0</p></td><td width="50" colspan="2" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>1</p></td><td width="54" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>2</p></td><td width="46" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>3</p></td><td width="48" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>4</p></td><td width="57" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>5</p></td><td width="44" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>6</p></td><td width="50" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>7</p></td><td width="50" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>8</p></td><td width="50" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>9</p></td></tr><tr><td width="55" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p>Pass 1</p></td><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>0</p></td><td width="50" colspan="2" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>1</p></td><td width="54" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>512</p></td><td width="46" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>343</p></td><td width="48" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>64</p></td><td width="57" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>125</p></td><td width="44" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>216</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>27</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>8</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>729</p></td></tr><tr><td width="55" rowspan="3" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p>Pass2</p></td><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>0</p></td><td width="50" colspan="2" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>512</p></td><td width="54" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>125</p></td><td width="46" rowspan="3" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="48" rowspan="3" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>343</p></td><td width="57" rowspan="3" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="44" rowspan="3" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>64</p></td><td width="50" rowspan="3" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="50" rowspan="3" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="50" rowspan="3" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td></tr><tr><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>1</p></td><td width="50" colspan="2" rowspan="2" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>216</p></td><td width="54" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>27</p></td></tr><tr><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>8</p></td><td width="54" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>729</p></td></tr><tr><td width="55" rowspan="5" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p>Pass3</p></td><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>0</p></td><td width="47" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>125</p></td><td width="57" colspan="2" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>216</p></td><td width="46" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>343</p></td><td width="48" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="57" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>512</p></td><td width="44" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="50" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>729</p></td><td width="50" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="50" rowspan="5" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td></tr><tr><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>1</p></td></tr><tr><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>8</p></td></tr><tr><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>27</p></td></tr><tr><td width="49" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>64</p></td></tr><tr><td width="68" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="62" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="58" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="4" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="68" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="57" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="60" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="72" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="56" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="62" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="62" style="border-width: initial;border-style: none;border-color: initial"><br/></td><td width="63" style="border-width: initial;border-style: none;border-color: initial"><br/></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp; 时间复杂度：T(N,B,P)=O(P(N+B))。其中P为基数排序次数（本例子例为3），N为输入序列中数字个数，B为整数进制。</p><h3>10.3.3 多关键字排序</h3><p style="text-indent:28px">例如，一副扑克牌是按2种关键字排序的，如图2所示，花色是它的主关键字，面值是它的次关键字。</p><p style="text-indent: 0em; text-align: center;"><img src="/wp-content/uploads/image/20180513/1526218273140431.jpg" title="1526218273140431.jpg" alt="1526218273140431.jpg" width="420" height="64"/></p><p style="text-indent: 0em; text-align: center;">图2</p><p style="text-indent:28px">在这里，我们可以用“主位优先”（Most Significant Digit, MSD）排序，为花色建立4个桶，在每个桶里分别排序，最后合并结果。</p><p style="text-indent:28px">也可以使用“次位优先”（LSD）算法排序，为面值建立13个桶，就可以直接将结果合并，然后为花色建4个桶，放进去就可以了。</p><p style="text-indent:28px">在这里，LSD优点是不需要排序，时间复杂度小的多。</p><p style="text-indent:28px">&nbsp;</p><p style="text-indent:28px">基数排序是<strong><span style="color:red">稳定</span></strong>的算法。</p><h3>补充</h3><p style="text-indent:28px">（1）次位优先的C语言代码：</p><pre class="brush:cpp;toolbar:false">/*&nbsp;基数排序&nbsp;-&nbsp;次位优先&nbsp;*/
&nbsp;
/*&nbsp;假设元素最多有MaxDigit个关键字，基数全是同样的Radix&nbsp;*/
#define&nbsp;MaxDigit&nbsp;4
#define&nbsp;Radix&nbsp;10
&nbsp;
/*&nbsp;桶元素结点&nbsp;*/
typedef&nbsp;struct&nbsp;Node&nbsp;*PtrToNode;
struct&nbsp;Node&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;key;
&nbsp;&nbsp;&nbsp;&nbsp;PtrToNode&nbsp;next;
};
&nbsp;
/*&nbsp;桶头结点&nbsp;*/
struct&nbsp;HeadNode&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PtrToNode&nbsp;head,&nbsp;tail;
};
typedef&nbsp;struct&nbsp;HeadNode&nbsp;Bucket[Radix];
&nbsp;
int&nbsp;GetDigit&nbsp;(&nbsp;int&nbsp;X,&nbsp;int&nbsp;D&nbsp;)
{&nbsp;/*&nbsp;默认次位D=1,&nbsp;主位D&lt;=MaxDigit&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;d,&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=1;&nbsp;i&lt;=D;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;X&nbsp;%&nbsp;Radix;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;/=&nbsp;Radix;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;d;
}
&nbsp;
void&nbsp;LSDRadixSort(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{&nbsp;/*&nbsp;基数排序&nbsp;-&nbsp;次位优先&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;D,&nbsp;Di,&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket&nbsp;B;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PtrToNode&nbsp;tmp,&nbsp;p,&nbsp;List&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;Radix;&nbsp;i++)&nbsp;/*&nbsp;初始化每个桶为空链表&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B[i].head&nbsp;=&nbsp;B[i].tail&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;N;&nbsp;i++)&nbsp;{&nbsp;/*&nbsp;将原始序列逆序存入初始链表List&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;(PtrToNode)malloc(sizeof(struct&nbsp;Node));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;key&nbsp;=&nbsp;A[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;next&nbsp;=&nbsp;List;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;下面开始排序&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(D=1;&nbsp;D&lt;=MaxDigit;&nbsp;D++)&nbsp;{&nbsp;/*&nbsp;对数据的每一位循环处理&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;下面是分配的过程&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;List;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(p)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Di&nbsp;=&nbsp;GetDigit(p-&gt;key,&nbsp;D);&nbsp;/*&nbsp;获得当前元素的当前位数字&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;从List中摘除&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;p;&nbsp;p&nbsp;=&nbsp;p-&gt;next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;插入B[Di]号桶尾&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(B[Di].head&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B[Di].head&nbsp;=&nbsp;B[Di].tail&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B[Di].tail-&gt;next&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B[Di].tail&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;下面是收集的过程&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Di=Radix-1;&nbsp;Di&gt;=0;&nbsp;Di--)&nbsp;{&nbsp;/*&nbsp;将每个桶的元素顺序收集入List&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(B[Di].head)&nbsp;{&nbsp;/*&nbsp;如果桶不为空&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;整桶插入List表头&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B[Di].tail-&gt;next&nbsp;=&nbsp;List;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;=&nbsp;B[Di].head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B[Di].head&nbsp;=&nbsp;B[Di].tail&nbsp;=&nbsp;NULL;&nbsp;/*&nbsp;清空桶&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;将List倒入A[]并释放空间&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;N;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;List;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;=&nbsp;List-&gt;next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[i]&nbsp;=&nbsp;tmp-&gt;key;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">（2）主位优先C语言代码：</p><pre class="brush:cpp;toolbar:false">/*&nbsp;基数排序&nbsp;-&nbsp;主位优先&nbsp;*/
/*&nbsp;假设元素最多有MaxDigit个关键字，基数全是同样的Radix&nbsp;*/
&nbsp;
#define&nbsp;MaxDigit&nbsp;4
#define&nbsp;Radix&nbsp;10
&nbsp;
/*&nbsp;桶元素结点&nbsp;*/
typedef&nbsp;struct&nbsp;Node&nbsp;*PtrToNode;
struct&nbsp;Node{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;key;
&nbsp;&nbsp;&nbsp;&nbsp;PtrToNode&nbsp;next;
};
&nbsp;
/*&nbsp;桶头结点&nbsp;*/
struct&nbsp;HeadNode&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;PtrToNode&nbsp;head,&nbsp;tail;
};
typedef&nbsp;struct&nbsp;HeadNode&nbsp;Bucket[Radix];
&nbsp;
int&nbsp;GetDigit&nbsp;(&nbsp;int&nbsp;X,&nbsp;int&nbsp;D&nbsp;)
{&nbsp;/*&nbsp;默认次位D=1,&nbsp;主位D&lt;=MaxDigit&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;d,&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=1;&nbsp;i&lt;=D;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;X%Radix;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;/=&nbsp;Radix;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;d;
}
&nbsp;
void&nbsp;MSD(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;L,&nbsp;int&nbsp;R,&nbsp;int&nbsp;D&nbsp;)
{&nbsp;/*&nbsp;核心递归函数:&nbsp;对A[L]...A[R]的第D位数进行排序&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Di,&nbsp;i,&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket&nbsp;B;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PtrToNode&nbsp;tmp,&nbsp;p,&nbsp;List&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(D==0)&nbsp;return;&nbsp;/*&nbsp;递归终止条件&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;Radix;&nbsp;i++)&nbsp;/*&nbsp;初始化每个桶为空链表&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B[i].head&nbsp;=&nbsp;B[i].tail&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=L;&nbsp;i&lt;=R;&nbsp;i++)&nbsp;{&nbsp;/*&nbsp;将原始序列逆序存入初始链表List&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;(PtrToNode)malloc(sizeof(struct&nbsp;Node));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;key&nbsp;=&nbsp;A[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;next&nbsp;=&nbsp;List;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;下面是分配的过程&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;List;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(p)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Di&nbsp;=&nbsp;GetDigit(p-&gt;key,&nbsp;D);&nbsp;/*&nbsp;获得当前元素的当前位数字&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;从List中摘除&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;p;&nbsp;p&nbsp;=&nbsp;p-&gt;next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;插入B[Di]号桶&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(B[Di].head&nbsp;==&nbsp;NULL)&nbsp;B[Di].tail&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp-&gt;next&nbsp;=&nbsp;B[Di].head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B[Di].head&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;下面是收集的过程&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;j&nbsp;=&nbsp;L;&nbsp;/*&nbsp;i,&nbsp;j记录当前要处理的A[]的左右端下标&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Di=0;&nbsp;Di&lt;Radix;&nbsp;Di++)&nbsp;{&nbsp;/*&nbsp;对于每个桶&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(B[Di].head)&nbsp;{&nbsp;/*&nbsp;将非空的桶整桶倒入A[],&nbsp;递归排序&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;B[Di].head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(p)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;p-&gt;next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[j++]&nbsp;=&nbsp;tmp-&gt;key;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;递归对该桶数据排序,&nbsp;位数减1&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSD(A,&nbsp;i,&nbsp;j-1,&nbsp;D-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;j;&nbsp;/*&nbsp;为下一个桶对应的A[]左端&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}
&nbsp;
void&nbsp;MSDRadixSort(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{&nbsp;/*&nbsp;统一接口&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;MSD(A,&nbsp;0,&nbsp;N-1,&nbsp;MaxDigit);
}</pre><h2>10.4 排序算法的比较</h2><table><tbody><tr class="firstRow"><td width="111" valign="top" style="border-top-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-color: rgb(68, 114, 196); border-bottom-color: rgb(68, 114, 196); border-left-color: rgb(68, 114, 196); border-right: none; background: rgb(68, 114, 196); padding: 0px 7px;"><p><strong><span style="color:white">排序方法</span></strong></p></td><td width="111" valign="top" style="border-top-width: 1px; border-top-color: rgb(68, 114, 196); border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(68, 114, 196); border-right: none; background: rgb(68, 114, 196); padding: 0px 7px;"><p><strong><span style="color:white">平均时间复杂度</span></strong></p></td><td width="111" valign="top" style="border-top-width: 1px; border-top-color: rgb(68, 114, 196); border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(68, 114, 196); border-right: none; background: rgb(68, 114, 196); padding: 0px 7px;"><p><strong><span style="color:white">最坏情况下时间复杂度</span></strong></p></td><td width="111" valign="top" style="border-top-width: 1px; border-top-color: rgb(68, 114, 196); border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(68, 114, 196); border-right: none; background: rgb(68, 114, 196); padding: 0px 7px;"><p><strong><span style="color:white">额外空间复杂度</span></strong></p></td><td width="111" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: rgb(68, 114, 196); border-right-color: rgb(68, 114, 196); border-bottom-color: rgb(68, 114, 196); border-left: none; background: rgb(68, 114, 196); padding: 0px 7px;"><p><strong><span style="color:white">稳定性</span></strong></p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: rgb(142, 170, 219); border-bottom-color: rgb(142, 170, 219); border-left-color: rgb(142, 170, 219); border-top: none; background: rgb(217, 226, 243); padding: 0px 7px;"><p><strong>简单选择排序</strong></p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(N<sup>2</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(N<sup>2</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(1)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>不稳定</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: rgb(142, 170, 219); border-bottom-color: rgb(142, 170, 219); border-left-color: rgb(142, 170, 219); border-top: none; padding: 0px 7px;"><p><strong>冒泡排序</strong></p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(N<sup>2</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(N<sup>2</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(1)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>稳定</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: rgb(142, 170, 219); border-bottom-color: rgb(142, 170, 219); border-left-color: rgb(142, 170, 219); border-top: none; background: rgb(217, 226, 243); padding: 0px 7px;"><p><strong>直接插入排序</strong></p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(N<sup>2</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(N<sup>2</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(1)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>稳定</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: rgb(142, 170, 219); border-bottom-color: rgb(142, 170, 219); border-left-color: rgb(142, 170, 219); border-top: none; background: rgb(0, 112, 192); padding: 0px 7px;"><p><strong><span style="color:white">希尔排序</span></strong></p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(N<sup>d</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(N<sup>2</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(1)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>不稳定</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: rgb(142, 170, 219); border-bottom-color: rgb(142, 170, 219); border-left-color: rgb(142, 170, 219); border-top: none; background: rgb(0, 112, 192); padding: 0px 7px;"><p><strong><span style="color:white">堆排序</span></strong></p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(NlogN)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(NlogN)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(1)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>不稳定</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: rgb(142, 170, 219); border-bottom-color: rgb(142, 170, 219); border-left-color: rgb(142, 170, 219); border-top: none; background: rgb(0, 112, 192); padding: 0px 7px;"><p><strong><span style="color:white">快速排序</span></strong></p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(NlogN)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(N<sup>2</sup>)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(logN)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>不稳定</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: rgb(142, 170, 219); border-bottom-color: rgb(142, 170, 219); border-left-color: rgb(142, 170, 219); border-top: none; background: rgb(0, 112, 192); padding: 0px 7px;"><p><strong><span style="color:white">归并排序</span></strong></p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(NlogN)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(NlogN)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>O(N)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); background: rgb(217, 226, 243); padding: 0px 7px;"><p>稳定</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: rgb(142, 170, 219); border-bottom-color: rgb(142, 170, 219); border-left-color: rgb(142, 170, 219); border-top: none; background: rgb(0, 112, 192); padding: 0px 7px;"><p><strong><span style="color:white">基数排序</span></strong></p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(P(N+B))</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(P(N+B))</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>O(N+B)</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: rgb(142, 170, 219); border-right-width: 1px; border-right-color: rgb(142, 170, 219); padding: 0px 7px;"><p>稳定</p></td></tr></tbody></table><p style="text-indent:28px">前三种排序算法的共同优点是算法编写简单。冒泡排序和直接插入排序每次都是交换两个元素，因此是慢的，但是它们稳定，简单选择排序是跳着交换，有可能不稳定。</p><p style="text-indent:28px">希尔排序算法打破了N的平方的复杂度，它的好坏取决于d（增量序列），因为是跳着排的，所以它也是不稳定的。</p><p style="text-indent:28px">堆排序和归并排序的时间复杂度是最好的，无论何时都是一样的。归并排序的缺点是它需要一个额外的空间，当数据量非常大的时候，只能排一半数据，但是它的优点是它是稳定的。堆排序理论上看很美，实际情况是虽然理论上是O(NlogN)，但是O这个常数会比较大，所以它到底跟快速排序哪个快，就难说了。堆排序和快速排序的共同缺点是不稳定，快速排序总可以构造一种最糟糕的情况是O(N<sup>2</sup>)，而且因为是递归的，所以额外空间是需要的，时间复杂度最好时，额外空间复杂度也是O(logN)。</p><p style="text-indent:28px">基数排序在某种情况下，会打破NlogN的魔咒，会更快，近乎线性。它需要的额外空间是需要B个桶，每个桶设置B个数据的位置，所以到底什么情况下合算，看情况，它的好处是它是稳定的。</p><p><br/></p><div style="background: rgb(0, 0, 0); opacity: 0.22; position: absolute !important; left: 0px !important; top: 0px !important; border: 0px none !important; padding: 0px !important; z-index: 100000; height: 0px; width: 0px; display: none;"></div>
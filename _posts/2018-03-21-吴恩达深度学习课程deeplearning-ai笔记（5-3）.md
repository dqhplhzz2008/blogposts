---
ID: 3699
post_title: >
  吴恩达深度学习课程DeepLearning.ai笔记（5-3）
post_name: '%e5%90%b4%e6%81%a9%e8%be%be%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e8%af%be%e7%a8%8bdeeplearning-ai%e7%ac%94%e8%ae%b0%ef%bc%885-3%ef%bc%89'
author: 小奥
post_date: 2018-03-21 20:52:20
layout: post
link: >
  http://www.yushuai.me/2018/03/21/3699.html
published: true
tags:
  - 人工智能
  - 神经网络
categories:
  - Deep Learning
---
<h1>第三周：序列模型和注意力机制</h1><h2>3.1 基础模型</h2><p><strong>1.序列到序列模型</strong></p><p><strong>【参考文献：Sutskever et. al., 2014. Sequence to sequence learning with neural networks, Cho et. al., 2014. Learning phrase representations using RNN encoder-decoder for statistical machine translation】</strong></p><p style="text-indent:28px">如图1所示，那么怎样训练处一个网络来输入序列x和输出序列y呢？这里有一些方法。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180321/1521636493115985.jpg" title="1521636493115985.jpg" alt="1521636493115985.jpg" width="479" height="260"/>&nbsp;</p><p style="text-align:center">图1</p><p style="text-indent:28px">首先，我们建立一个网络，这个网络叫做编码网络，它是一个RNN网络，RNN单元可以是LSTM也可以GRU，每次只向网络中输入一个法语单词，将输入序列接收完毕后，RNN网络会输出一个向量来代表输入，之后可以建立一个解码网络。它以编码网络未输入，之后它可以被训练每次输出一个翻译后的单词，一直到输出序列的结尾为止。和往常一样，我们都可以把上一个的输入作为下一个预测的参考.</p><p><strong>2. 看图说话</strong></p><p><strong>【参考文献：Mao et. al., 2014. Deep captioning with multimodal recurrent neural networks]，Vinyals et. al., 2014. Show and tell: Neural image caption generator，Karpathy and Li, 2015. Deep visual-semantic alignments for generating image descriptions】</strong></p><p style="text-indent:28px">如何将图片输入到CNN中，然后学习图片的一些特征，图2所示的就是AlexNet结构，如果我们去掉softmax，这个网络会给你4096维单元，所以这个预处理的网络可能是图像的编码，接着把向量输入到RNN，RNN用来生成图像的描述。现在你输入一个特征向量，RNN输出一个单词描述。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180321/1521636509272382.jpg" title="1521636509272382.jpg" alt="1521636509272382.jpg" width="479" height="251"/></p><p style="text-align:center">图2</p><h2>3.2 选择最可能的句子</h2><p style="text-indent:28px">我们可以将机器翻译看作是建立一个条件语言模型。在语言模型中，图3中第一部分是第一周所建立的模型，这个模型可以让你能够估计句子的可能性，这就是语言模型所做的事情，你也可以将它用于生成一个新的句子。</p><p style="text-indent:28px">而机器翻译模型则是下面这样的，用两种不同颜色表示编码和解码网络。你会发现解码网络和刚才画的语言模型几乎一模一样，他们不同的是语言模型通常以0向量开始，而编码网络会计算出一系列向量来表示输入的句子，而不是以0向量开始，因此及其翻译模型解码器这里被称为“条件语言模型”。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180321/1521636525118245.jpg" title="1521636525118245.jpg" alt="1521636525118245.jpg" width="479" height="211"/></p><p style="text-align:center">图3</p><p style="text-indent:28px">现在如果你真的想通过模型将法语翻译成英文，通过输入的法语句子，模型将告诉你各种翻译结果所对应的概率。显然不能随机输出。当你使用这个模型来进行机器翻译的时候，你并不是从得到的分布P（y<sup>&lt;1&gt;</sup>,…y<sup>&lt;Ty&gt;</sup>）中进行随机采样，而是要找到一个英语句子y使得条件概率最大化。所以你需要找出合适的y值来使其最大化。</p><p style="text-indent:28px">在这之前，为什么不用贪心查找算法（greedy search）呢？贪心查找算法是一种生成第一个词的分布以后，会根据你的条件语言模型挑选出最后可能的第一个词，进入你的机器翻译模型中，他会依次选择最可能的词语。但是你真正需要的是一次性挑选出所有需要的单词来使得整体概率最大化，所以这种贪心算法并不合适。</p><p style="text-indent:28px">具体所需要的算法将在下一节讲述。</p><h2>3.3 定向搜索</h2><p style="text-indent:28px">本节学习集束搜索（Beam search）算法，如图4所示。</p><p style="text-indent:28px">第一步，挑选出英语翻译的第一个单词。这里为了简略表示，所以所有单词都以小写列出来。右侧最上面绿色的是编码部分，紫色的是解码部分，来评估第一个单词的概率值P(y<sup>&lt;1&gt;</sup>|x)，而本算法考虑更多。这里多了一个B参数，集束宽。这里设为3，是一次考虑3个。然后算法会把结果存在内存，后面依次做尝试。</p><p style="text-indent:28px">第二步，选出了最可能的三个词后，算法会针对每个第一个单词考虑第二个单词是什么，为了评估第二个单词，还是需要这样一个编码器和解码器，注意同样需要考虑第一个单词的前提，计算第一个单词前提下第二个单词是什么。这样就可以估测第二个单词的概率了。在第二步中我们更主要考虑（第一个-第二个单词）对有最大的概率。按照条件概率准则，这可以表示成第一个单词的概率乘第二个单词的概率。所以对于集束搜索第二步，由于我们一直用的集束宽为3，那么最终我们有30000个可能，就是集束宽乘词汇库的大小。</p><p style="text-indent:28px">每一步我们都是复制3个单词来进行评估。这三个网络可以高效评估概率模型。这样就可以输出所要求的总体最大概率模型。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180321/1521636541217642.jpg" title="1521636541217642.jpg" alt="1521636541217642.jpg" width="479" height="267"/></p><p style="text-align:center">图4</p><h2>3.4 改进定向搜索</h2><p><strong>1.长度归一化</strong></p><p style="text-indent:28px">束搜索就是最大化如图5中第一个式子这个概率。如果计算这些概率，通常这些概率都是远小于1，相乘就远小于1，可能会数值下溢，所以实际上我们经常用第二个式子。通过取log我们可以取得一个数值上更稳定的结果，因为log函数是严格递增函数，所以两者可以说是等同的。对于目标函数还可以做些改变，使效果更好，所以可以看到第三个式子，在第二个式子的基础上做一个归一化，也就是除以单词总数。α也是同样的一个试验性的超参数，尝试不同的α来得到更好的结果。</p><p style="text-align:center">&nbsp;</p><p style="text-align:center">图5</p><p><strong>2.集束搜索讨论</strong></p><p style="text-indent:28px">B越大，你需要考虑的可能性越多，找到的结果也可能越好，但是计算代价也可能越大，内存占用也会很大。如果用小B，计算结果可能并不是那么好，但是你的计算代价低，内存占用少。产品级通常设置B=10，但是对于科研来说，一般B甚至可以取到1000或者3000。</p><p style="text-indent:28px">不像BFS（Breadth First Search）和DFS（Depth First Search）等实际搜索算法，集束搜索算法运行更快，但是并不保证实际找到所求概率的最大值。</p><h2>3.5 定向搜索的误差分析</h2><p style="text-indent:28px">本算法是一个近似搜索算法。假设原来的句子是：</p><p>Jane visite l’Afrique en septembre.</p><p style="text-indent:28px">人类的翻译定为y<sup>*</sup>，是：</p><p>Jane visits Africa in September</p><p style="text-indent:28px">计算机的翻译定为y^，是：</p><p>Jane visited Africa last September.</p><p style="text-indent:28px">那么可以看出，计算机的翻译非常糟糕。你的模型有两个主要部分，一个是神经网络部分，或者说是序列到序列模型，即RNN，实际上是编码器和解码器；另一个部分是束搜索算法，以B来进行搜索。那么是RNN还是束搜索算法出错了呢？</p><p style="text-indent:28px">在之前说大量收集数据，这的确是没有危害的，但是就像单纯获取更多训练数据，可能不能得到想要的结果，单纯增大束宽也不能得到你想要的结果。下面我们来分析一下什么时候该用什么方法。</p><p style="text-indent:28px">循环神经网络，实际上一个编码器和解码器组成，它计算P(y|x)，所以举个例子对于这个句子来说，如图6所示，紫色部分填入那三个单词，然后就会计算这个概率。结果表明，你此时能做的最有效的事情就是用这个模型计算P(y|x)同时也用你的RNN模型计算P(y|x)，然后比较哪个值更大。左边大于右边或者右边大于左边将有助于我们确定这个特定的错误是RNN还是束搜索算法的问题。</p><p style="text-indent: 0em; text-align: center;"><img src="/wp-content/uploads/image/20180321/1521636615342271.jpg" title="1521636615342271.jpg" alt="1521636615342271.jpg" width="359" height="84"/></p><p style="text-indent: 0em; text-align: center;">图6<br/></p><p style="text-indent:28px">现在来分情况讨论P（y<sup>*</sup>|x）为RNN计算的概率，P(y^|x)为波搜索算法的概率：</p><p style="text-indent:28px">第一种情况P(y<sup>*</sup>|x)&gt;P(y^|x)，BS（波搜索算法）选择了y^，但是y<sup>*</sup>获得更高的P，书搜索算法实际上不能够给你取得最大的P的y值，所以这里得出BS是错的</p><p style="text-indent:28px">第二种情况P(y<sup>*</sup>|x)&lt;P(y^|x)，y<sup>*</sup>是一个更好的结果，但是RNN预测了P(y<sup>*</sup>|x)&lt;P(y^|x)，看来是RNN模型出错了。</p><h2>3.6 Bleu得分（略）</h2><p><strong><span style="color:#0D0D0D">本部分不学习</span></strong></p><h2>3.7 注意力模型直观理解</h2><p><strong>1.长序列问题</strong></p><p style="text-indent:28px">如图7所示。像这样给定一个很长的法语句子，在你的神经网络中，绿色的编码器就是接收这个句子并且记住这个句子，然后在感知机中传递，而对于这个紫色的来说产生英文翻译。</p><p style="text-indent:28px">人类翻译总是一部分一部分翻译。你在下面这个图里面可以看到Bleu评分和句子长度的关系。</p><p style="text-indent:28px">注意力模型就是一次只翻译一部分，它的评分就是图中绿色的线。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180321/1521636629112101.jpg" title="1521636629112101.jpg" alt="1521636629112101.jpg" width="479" height="266"/>&nbsp;</p><p style="text-align:center">图7</p><p><strong>2.注意力模型直观理解</strong></p><p><strong>【参考文献：Bahdanau et. al., 2014. Neural machine translation by jointly learning to align and translate】</strong></p><p style="text-indent:28px">这个模型在深度学习非常有影响力。这里我们采用一个短句子来理解如图8，假定每个单词是x<sup>&lt;1&gt;,</sup>x<sup>&lt;2&gt;</sup>,x<sup>&lt;3&gt;</sup>,x<sup>&lt;4&gt;</sup>,x<sup>&lt;5&gt;</sup>，使用一个双向的RNN结构，为了计算每个单词的特征值，你必须理解从Y1到Y5的RNN，但是我们不是翻译单个单词，所以先无视掉上面的y系列，就用双向的RNN，我们都做的是对这五个单词的每个单词计算特征集，也有可能是周围的词。我们将使用另一个RNN来产生英文翻译。用S来表示感知器，图为最上面手画的图。问题在于，当你尝试第一个生成第一个单词，即输出，那么我们应该看输入法语句子的哪个部分？似乎应该先看第一个单词。所以注意力模型就会计算权重，用a&lt;1,1&gt;计算第一个信息块的权重，然后计算第二个、第三个等后面的注意力权重，这些会高速我们应该花多少注意力去在上下文C中使用。然后我们会有一个新的隐藏层S&lt;2&gt;，然后使用a&lt;2,1&gt;，a&lt;2,2&gt;……来告诉我哪个单词用来生成第二个单词。然后依次进行下去。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180321/1521636655133358.jpg" title="1521636655133358.jpg" alt="1521636655133358.jpg" width="479" height="258"/></p><p style="text-align:center">图8</p><h2>3.8 注意力辨识</h2><p><strong>1.注意力模型</strong></p><p style="text-indent:28px">注意力模型更像人类翻译。如图9所示，其实跟图8类似，实际上GRU和LSTM，特别是LSTM经常被应用到这里面。具体过程在上一节已经讲了，不再累述。为了简化每个时间步的记号，就用a&lt;t&gt;来表示时间步t上的特征向量。接下来我们只用向前来讲，就是图9上面手画的图。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180321/1521636679682772.jpg" title="1521636679682772.jpg" alt="1521636679682772.jpg" width="479" height="269"/>&nbsp;</p><p style="text-align:center">图9</p><p><strong>2.计算注意力</strong></p><p><strong>【参考文献：Xu et. al., 2015. Show, attend and tell: Neural image caption generation with visual attention】</strong></p><p>如图10所示。如何计算e呢？就用公式下面这个图像来计算。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180321/1521636694508556.jpg" title="1521636694508556.jpg" alt="1521636694508556.jpg" width="479" height="185"/>&nbsp;</p><p style="text-align:center">图10</p><h2>3.9 语音识别</h2><p><strong>1.语音识别问题</strong></p><p>&nbsp;&nbsp;&nbsp; 给你一个语音片段x，你的任务是自动生成文本y。音频片段的预处理操作一般是生成频谱图。过去语音识别是用音位键来构建，但是现在DeepLearning中这种已经不需要了，现在只需要建立一个系统就可以直接输出所对应的文本。</p><p><strong>2.语音识别的注意力模型</strong></p><p style="text-indent:28px">在输入音频不同时间帧上用注意力模型，如图11所示。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180321/1521636708774612.jpg" title="1521636708774612.jpg" alt="1521636708774612.jpg" width="479" height="272"/></p><p style="text-align:center">图11</p><p><strong>3. CTC cost for speech recognition</strong></p><p><strong>【参考文献：Graves et al., 2006. Connectionist Temporal Classification: Labeling</strong></p><p><strong>&nbsp;unsegmented sequence data with recurrent neural networks】</strong></p><p style="text-indent:28px">还有一种很有效的方法是用CTC损失函数来做语音识别。如图12所示，这是系统的结构，实际可能是LSTM或者双向GIU模型。假设原句是“the quick brown fox”，CTC允许RNN生成这样的输出，ttt这是一个空白输出。这句话的开头的音可以表示为ttt_h_eee___ ___qqq__，（用那个符号表示空格，下划线表示空白）。CTC损失函数就是将空白符之间重复的字符折叠起来，这样便输出“the q”。通过允许神经网络有重复字符和空白字符，可以由1000字符输出。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180321/1521636724812718.jpg" title="1521636724812718.jpg" alt="1521636724812718.jpg" width="479" height="240"/></p><p style="text-align:center">图12</p><h2>3.10 触发字检测</h2><p>还没有中文翻译，暂且留空</p>
---
ID: 3785
post_title: >
  数据结构【浙江大学】（第9节）整理
post_name: '%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e3%80%90%e6%b5%99%e6%b1%9f%e5%a4%a7%e5%ad%a6%e3%80%91%ef%bc%88%e7%ac%ac9%e8%8a%82%ef%bc%89%e6%95%b4%e7%90%86'
author: 小奥
post_date: 2018-05-12 16:24:47
layout: post
link: >
  http://www.yushuai.me/2018/05/12/3785.html
published: true
tags:
  - 数据结构
categories:
  - Data Structure
---
<h1>第九节：排序（上）</h1><h2>9.1 概述</h2><p>对于之后应用到的一些说明：</p><p style="text-indent:28px">（1）void X_Sort(ElementType A[], int N) X为排序名称。</p><p style="text-indent:28px">①大多数情况下，为了简单起见，讨论从小到大的整数排序。</p><p style="text-indent:28px">②默认N为正整数。</p><p style="text-indent:28px">③只讨论基于比较的排序（&gt;=&lt;都是有定义的）。</p><p style="text-indent:28px">④只讨论内部排序（一次性可以写入内存，然后只在内存里面的数据排序）。</p><p style="text-indent:28px">⑤稳定性：任意两个相等的数据，排序前后的相对位置不发生改变。</p><p style="text-indent:28px"><strong><span style="color:red">没有一种排序是任何情况下都表现最好的！！！</span></strong></p><h2>9.2 简单排序算法</h2><h3><span style="font-weight:normal">9.2.1 </span><span style="font-weight:normal">冒泡排序</span></h3><p style="text-indent:28px">在一次排序完成后，最后面的一定是最大的，第二次排序的时候只需要对前N-1个排序即可，然后N-2……一直到最后完成。</p><p style="text-indent:28px">冒泡排序的伪码描述如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Bubble_Sort(ElementType&nbsp;A[],&nbsp;int&nbsp;N)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(P=N-1;P&gt;=0;P--)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;P;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{/*一趟冒泡*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(A[i]&gt;A[i+1])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(A[i],A[i+1);]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;1;/*标志发生了交换*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(flag==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;/*全程无交换，已经排好*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>最好情况：顺序T=O(N)；最差情况：逆序T=O(N<sup>2</sup>)</p><p>这个算法具有<strong><span style="color:red">稳定性</span></strong>！</p><h3><span style="font-weight:normal">9.2.2 </span><span style="font-weight:normal">插入排序</span></h3><p style="text-indent:28px">类似于打扑克的时候拿到牌之后进行排序 。</p><p style="text-indent:28px">源代码：</p><pre class="brush:cpp;toolbar:false">void&nbsp;InsertionSort(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{&nbsp;/*&nbsp;插入排序&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;P,&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;Tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;P=1;&nbsp;P&lt;N;&nbsp;P++&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tmp&nbsp;=&nbsp;A[P];&nbsp;/*&nbsp;取出未排序序列中的第一个元素*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=P;&nbsp;i&gt;0&nbsp;&amp;&amp;&nbsp;A[i-1]&gt;Tmp;&nbsp;i--&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[i]&nbsp;=&nbsp;A[i-1];&nbsp;/*依次与已排序序列中元素比较并右移*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[i]&nbsp;=&nbsp;Tmp;&nbsp;/*&nbsp;放进合适的位置&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>最好情况：顺序T=O(N)</p><p>最坏情况：逆序T=O (N<sup>2</sup>)</p><p style="text-indent:28px">此方法也具有<strong>稳定性</strong>。</p><p>举例，问序列{34,8,64,51,32,21}中用插入排序和冒泡排序分别需要交换多少次？</p><p>答：冒泡法：9次；插入法，9次。</p><p>&nbsp;&nbsp;&nbsp; 它们的次数相等，是巧合还是必然？见下一节。</p><h3><span style="font-weight:normal">9.2.3 </span><span style="font-weight:normal">时间复杂度下界</span></h3><p><strong>1.逆序对</strong></p><p style="text-indent:28px">对于下标i&lt;j，如果A[i]&gt;A[j]，则称(i,j)是一对<strong>逆序对</strong>（inversion）。</p><p style="text-indent:28px">我们来看上一节中最后的序列{34,8,64,51,32,21}，它里面有多少逆序对呢？</p><p>(34,8)(34,42)(34,21)(64,51)(64,21)(64,21)(51,32)(51,21)(32,21)</p><p style="text-indent:28px">一共9个逆序对。这说明，前面两种算法，<strong><span style="color:red">交换2个相邻元素正好消去1个逆序对</span></strong>！</p><p style="text-indent:28px"><strong>插入排序</strong>时间复杂度：<strong>T(N,I)=O(N+I)</strong>。这里面N是元素个数，I是逆序对个数。这个可以这样理解，时间复杂度最低为元素个数N，即逆序对为0，也就是顺序排列情况下；然后随着多一个逆序对，复杂度加1。</p><p style="text-indent:28px">如果序列<strong><span style="color:red">基本有序</span></strong>，那么<strong><span style="text-decoration:underline;">插入排序</span></strong>简单且高效。</p><p><strong>2.定理1：任意N个不同元素组成的序列平均具有<span style="color:red">N(N-1)/4</span>个逆序对。</strong></p><p><strong>3.定理2：任何仅以<span style="color:#4472C4">交换相邻两元素</span>来排序的算法，其平均时间复杂度为<span style="color:red">Ω（N<sup>2</sup>）</span>。（</strong><em><span style="color:#7F7F7F">注意：Ω是下界，O是上界）</span></em></p><p>&nbsp;&nbsp;&nbsp; 这意味着，要提高算法效率，我们必须：每次消去不止1个逆序对！每次交换相隔较远的2个元素！</p><h2>9.3 希尔排序</h2><p><strong>1.简单举例</strong></p><p style="text-indent:28px">它利用了插入排序的简单，同时克服了交换每次只交换相邻两个元素的缺点。</p><p style="text-indent:28px">用下面这个序列来进行希尔排序的举例：</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p>81</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>94</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>11</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>96</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>12</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>35</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>17</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>95</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>28</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>58</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>41</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>75</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>15</p></td></tr></tbody></table><p style="text-indent:28px">（1）<strong>首先以每5个元素取一个的规律进行排序</strong>：这里取了81、35、41。用插入排序对其进行排序：</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#0070C0">35</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>94</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>11</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>96</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>12</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">41</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>17</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>95</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>28</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>58</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">81</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>75</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>15</p></td></tr></tbody></table><p style="text-indent:28px">然后取94、17、75进行插入排序，得到下面的结果：</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#0070C0">35</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">17</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>11</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>96</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>12</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">41</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">75</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>95</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>28</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>58</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">81</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">94</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>15</p></td></tr></tbody></table><p style="text-indent:28px">然后考虑11、95、15，得到下面结果：</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#0070C0">35</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">17</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">11</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>96</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>12</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">41</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">75</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">15</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>28</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>58</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">81</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">94</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">95</span></strong></p></td></tr></tbody></table><p style="text-indent:28px">然后考虑96、28，得到下面结果：</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#0070C0">35</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">17</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">11</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#FFC000">28</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>12</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">41</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">75</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">15</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#FFC000">96</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>58</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">81</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">94</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">95</span></strong></p></td></tr></tbody></table><p style="text-indent:28px">然后考虑12和58：</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#0070C0">35</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">17</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">11</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#FFC000">28</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#70AD47">12</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">41</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">75</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">15</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#FFC000">96</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#70AD47">58</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#0070C0">81</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#ED7D31">94</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#A5A5A5">95</span></strong></p></td></tr></tbody></table><p style="text-indent:28px">（2）<strong>再用每3个元素取一个的规律</strong>进行排序：这里取35、28、75、58、95，结果如下：</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong><span style="color:#833C0B">28</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#C00000">12</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:red">11</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#833C0B">35</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#C00000">15</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:red">41</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#833C0B">58</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#C00000">17</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:red">94</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#833C0B">75</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#C00000">81</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:red">96</span></strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong><span style="color:#833C0B">95</span></strong></p></td></tr></tbody></table><p style="text-indent:28px">（3）再做1间隔排序（即普通插入排序）。我们可以发现，此时整个序列已经基本有序，所以此时插入排序简单高效。</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p><strong>11</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>12</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>15</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>17</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>28</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>35</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>41</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>58</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>75</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>81</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>94</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>95</strong></p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p><strong>96</strong></p></td></tr></tbody></table><p style="text-indent:28px">该算法的步骤：</p><p style="text-indent:28px">①.定义增量序列D<sub>M</sub>&gt;D<sub>M-1</sub>&gt;…&gt;D<sub>1</sub>=1</p><p style="text-indent:28px">②对每个D<sub>k</sub>进行“D<sub>k</sub>-间隔”排序。</p><p style="text-indent:28px">注意：“D<sub>k</sub>-间隔”有序的序列，在执行“D<sub>k-1</sub>-间隔”排序后，仍然是“D<sub>k</sub>-间隔”有序的。</p><p><strong>2.希尔增量序列</strong></p><p style="text-indent:28px">（1）原始希尔排序：D<sub>M</sub>=[N/2]，D<sub>k</sub>=[D<sub>k+1</sub>/2]。其中，[]代表取整。</p><p style="text-indent:28px">伪代码如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Shell_Sort(ElementType&nbsp;A[],&nbsp;int&nbsp;N)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(D=N/2;D&gt;0;D/=2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(P=D;P&lt;N;P++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tmp=&nbsp;A[P];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=P;i&gt;=D&amp;&amp;A[i-D]&gt;Tmp;i-=D)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[i]=A[i-D];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[i]=Tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>最坏情况：T=<strong>θ(N<sup>2</sup>)</strong>（<strong>θ代表即使上界也是下界，即可以达到的值</strong>）</p><p style="text-indent:28px">这种情况即，增量元素不互质，则小增量可能根本不起作用。</p><p><strong>3.其它增量序列</strong></p><p style="text-indent:28px">（1）Hibbard增量序列：D<sub>k</sub>=2<sup>k</sup>-1（相邻元素互质）。最坏情况：<strong>T=θ(N<sup>3/2</sup>)</strong>，猜想<strong>T<sub>avg</sub>=O(N<sup>5/4</sup>)</strong>。</p><p style="text-indent:28px">（2）Sedgewick增量序列：{1,5,19,41,109}（9×4<sup>i</sup>-9×2<sup>i</sup>+1或4<sup>i</sup>-3×2<sup>i</sup>+1），猜想<strong>T<sub>avg</sub>=O(N<sup>7/6</sup>)</strong>，<strong>T<sub>worst</sub>=O(N<sup>4/3</sup>)</strong>。</p><p><strong>4.稳定性：不稳定。</strong></p><h2>9.4 堆排序</h2><h3><span style="font-weight:normal">9.4.1 </span><span style="font-weight:normal">选择排序</span></h3><pre class="brush:cpp;toolbar:false">void&nbsp;Selection_Sort(ElementType&nbsp;A[],&nbsp;int&nbsp;N)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;N;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinPosition&nbsp;=&nbsp;ScanForMin(A,&nbsp;i&nbsp;N-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*从A[i]到A[N-1]中找最小元，并将其位置赋给MinPosition*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(A[i],&nbsp;A[MinPosition]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*将未排序部分的最小元换到有序部份的最后位置*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">无论如何，<strong>T=θ(N<sup>2</sup>)</strong>。</p><p style="text-indent:28px">如何快速寻找到最小元？见下一节。</p><h3><span style="font-weight:normal">9.4.2 </span><span style="font-weight:normal">堆排序（选择排序的改进）</span></h3><p><strong>1.算法1：</strong></p><pre class="brush:cpp;toolbar:false">void&nbsp;Heap_Sort&nbsp;(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BuildHeap(A);&nbsp;/*调整为最小堆，复杂度为O(N)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=0;&nbsp;i&lt;N;&nbsp;i++&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA[i]&nbsp;=&nbsp;DeleteMin(A);&nbsp;/*以此把最小元弹出来放到这个临时数组中*/
/*复杂度为O(logN)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=0;&nbsp;i&lt;N;&nbsp;i++&nbsp;)/*&nbsp;O(N)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[i]&nbsp;=&nbsp;TmpA[i];/*把临时数组的数组返回原来的数组*/
}</pre><p>时间复杂度：<strong>T(N)=O(NlogN)</strong></p><p>缺点：需要额外O(N)空间，并且复制元素需要时间。</p><p><strong>2.算法2：</strong></p><p><strong><span style="color:red">注意，在堆排序里面的这个堆，元素是从0的位置开始的；原来学堆的时候，0是用来放哨兵的。</span></strong></p><p>&nbsp;&nbsp;&nbsp; 因此，<span style=";color:#333333;background:white">在堆排序中，元素下标从</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#333333;background:white">0</span><span style=";color:#333333;background:white">开始。则对于下标为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#333333;background:white">i</span><span style=";color:#333333;background:white">的元素，其左、右孩子的下标分别为：</span><strong><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#333333;background:white">2i+1</span></strong><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#333333;background:white">, <strong>2i+2</strong></span><span style=";color:#333333;background:white">。</span></p><p>&nbsp;&nbsp;&nbsp; 伪码描述如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Heap_Sort&nbsp;(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=N/2-1;&nbsp;i&gt;=0;&nbsp;i--&nbsp;)/*&nbsp;BuildHeap&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PercDown(&nbsp;A,&nbsp;i,&nbsp;N&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=N-1;&nbsp;i&gt;0;&nbsp;i--&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(&nbsp;&amp;A[0],&nbsp;&amp;A[i]&nbsp;);&nbsp;/*&nbsp;DeleteMax&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PercDown(&nbsp;A,&nbsp;0,&nbsp;i&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><strong>定理：堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(Nlog logN)。</strong></p><p><strong><span style="color:red">注意：虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。</span></strong></p><p style="text-indent:28px"><strong>整体C语言源代码：</strong></p><pre class="brush:cpp;toolbar:false">void&nbsp;Swap(&nbsp;ElementType&nbsp;*a,&nbsp;ElementType&nbsp;*b&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;t&nbsp;=&nbsp;*a;&nbsp;*a&nbsp;=&nbsp;*b;&nbsp;*b&nbsp;=&nbsp;t;
}
&nbsp;
void&nbsp;PercDown(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;p,&nbsp;int&nbsp;N&nbsp;)
{&nbsp;/*&nbsp;改编代码4.24的PercDown(&nbsp;MaxHeap&nbsp;H,&nbsp;int&nbsp;p&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;/*&nbsp;将N个元素的数组中以A[p]为根的子堆调整为最大堆&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Parent,&nbsp;Child;
&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;X;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;A[p];&nbsp;/*&nbsp;取出根结点存放的值&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;Parent=p;&nbsp;(Parent*2+1)&lt;N;&nbsp;Parent=Child&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Child&nbsp;=&nbsp;Parent&nbsp;*&nbsp;2&nbsp;+&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;(Child!=N-1)&nbsp;&amp;&amp;&nbsp;(A[Child]&lt;A[Child+1])&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Child++;&nbsp;&nbsp;/*&nbsp;Child指向左右子结点的较大者&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;X&nbsp;&gt;=&nbsp;A[Child]&nbsp;)&nbsp;break;&nbsp;/*&nbsp;找到了合适位置&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;/*&nbsp;下滤X&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[Parent]&nbsp;=&nbsp;A[Child];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;A[Parent]&nbsp;=&nbsp;X;
}
&nbsp;
void&nbsp;HeapSort(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{&nbsp;/*&nbsp;堆排序&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=N/2-1;&nbsp;i&gt;=0;&nbsp;i--&nbsp;)/*&nbsp;建立最大堆&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PercDown(&nbsp;A,&nbsp;i,&nbsp;N&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=N-1;&nbsp;i&gt;0;&nbsp;i--&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;删除最大堆顶&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(&nbsp;&amp;A[0],&nbsp;&amp;A[i]&nbsp;);&nbsp;/*&nbsp;见代码7.1&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PercDown(&nbsp;A,&nbsp;0,&nbsp;i&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><h2>9.5 归并排序</h2><h3><span style="font-weight:normal">9.5 1</span><span style="font-weight:normal">有序子列的归并</span></h3><p><strong>1.举例</strong>：假设我们有两个有序序列如下：</p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-color: windowtext;padding: 0 7px"><p>1</p></td><td valign="top" style="border-top-width: 1px;border-right-width: 1px;border-bottom-width: 1px;border-top-color: windowtext;border-right-color: windowtext;border-bottom-color: windowtext;border-left: none;padding: 0 7px"><p>13</p></td><td valign="top" style="border-top-width: 1px;border-right-width: 1px;border-bottom-width: 1px;border-top-color: windowtext;border-right-color: windowtext;border-bottom-color: windowtext;border-left: none;padding: 0 7px"><p>24</p></td><td valign="top" style="border-top-width: 1px;border-right-width: 1px;border-bottom-width: 1px;border-top-color: windowtext;border-right-color: windowtext;border-bottom-color: windowtext;border-left: none;padding: 0 7px"><p>26</p></td></tr></tbody></table><p>&nbsp;</p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-color: windowtext;padding: 0 7px"><p>2</p></td><td valign="top" style="border-top-width: 1px;border-right-width: 1px;border-bottom-width: 1px;border-top-color: windowtext;border-right-color: windowtext;border-bottom-color: windowtext;border-left: none;padding: 0 7px"><p>15</p></td><td valign="top" style="border-top-width: 1px;border-right-width: 1px;border-bottom-width: 1px;border-top-color: windowtext;border-right-color: windowtext;border-bottom-color: windowtext;border-left: none;padding: 0 7px"><p>27</p></td><td valign="top" style="border-top-width: 1px;border-right-width: 1px;border-bottom-width: 1px;border-top-color: windowtext;border-right-color: windowtext;border-bottom-color: windowtext;border-left: none;padding: 0 7px"><p>38</p></td></tr></tbody></table><p style="text-indent:28px">我们要将它们合并成一个序列并按照顺序排序。我们需要设置三个指针，如图1所示。Aptr指向A序列的第一个元素（1），Bptr指向B序列的第一个元素（2），Cptr指向合并后的第一个元素。这里的指针其实是三个整数，分别存储的三个元素的下标。首先比较Aptr和Bptr指向的元素那个比较小，选择比较小的放入Cptr所代表的下标的那个位置。然后将Aptr加1，Cptr加1，用Bptr所代表的的下标的元素和Aptr所代表的的下标的元素比较，发现Bptr下标的元素（2）小，将2存入Cptr代表下标的元素，即C[Cptr]。然后依次类推。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180512/1526113422133621.jpg" title="1526113422133621.jpg" alt="1.jpg"/></p><p style="text-align:center">图1</p><p style="text-indent:28px"><strong>时间复杂度T(N)=O(N)</strong>。</p><p style="text-indent:28px">伪代码描述如下：</p><pre class="brush:cpp;toolbar:false">/*&nbsp;L&nbsp;=&nbsp;左边起始位置,&nbsp;R&nbsp;=&nbsp;右边起始位置,&nbsp;RightEnd&nbsp;=&nbsp;右边终点位置&nbsp;*/
void&nbsp;Merge(&nbsp;ElementType&nbsp;A[],&nbsp;ElementType&nbsp;TmpA[],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;L,&nbsp;int&nbsp;R,&nbsp;int&nbsp;RightEnd&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LeftEnd&nbsp;=&nbsp;R&nbsp;-&nbsp;1;&nbsp;/*&nbsp;左边终点位置。假设左右两列挨着&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tmp&nbsp;=&nbsp;L;&nbsp;/*&nbsp;存放结果的数组的初始位置&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumElements&nbsp;=&nbsp;RightEnd&nbsp;-&nbsp;L&nbsp;+&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;L&nbsp;&lt;=&nbsp;LeftEnd&nbsp;&amp;&amp;&nbsp;R&nbsp;&lt;=&nbsp;RightEnd&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;A[L]&nbsp;&lt;=&nbsp;A[R]&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA[Tmp++]&nbsp;=&nbsp;A[L++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;TmpA[Tmp++]&nbsp;=&nbsp;A[R++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;L&nbsp;&lt;=&nbsp;LeftEnd&nbsp;)&nbsp;/*&nbsp;直接复制左边剩下的&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA[Tmp++]&nbsp;=&nbsp;A[L++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;R&nbsp;&lt;=&nbsp;RightEnd&nbsp;)&nbsp;/*直接复制右边剩下的&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA[Tmp++]&nbsp;=&nbsp;A[R++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;NumElements;i++,RightEnd--)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[RightEnd]&nbsp;=&nbsp;TmpA[RightEnd];
}</pre><h3><span style="font-weight:normal">9.5.2</span><span style="font-weight:normal">递归算法</span></h3><p><strong>1.分而治之</strong></p><p style="text-indent:28px">如图2所示，该算法是<strong>稳定的</strong>。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180512/1526113401102417.jpg" title="1526113401102417.jpg" alt="2.jpg"/>&nbsp;</p><p style="text-align:center">图2</p><p style="text-indent:28px">伪码描述如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;MSort(&nbsp;ElementType&nbsp;A[],&nbsp;ElementType&nbsp;TmpA[],&nbsp;int&nbsp;L,&nbsp;int&nbsp;RightEnd&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Center;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;L&nbsp;&lt;&nbsp;RightEnd&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Center&nbsp;=&nbsp;(&nbsp;L&nbsp;+&nbsp;RightEnd&nbsp;)&nbsp;/&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSort(&nbsp;A,&nbsp;TmpA,&nbsp;L,&nbsp;Center&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSort(&nbsp;A,&nbsp;TmpA,&nbsp;Center+1,&nbsp;RightEnd&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge(&nbsp;A,&nbsp;TmpA,&nbsp;L,&nbsp;Center+1,&nbsp;RightEnd&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>&nbsp;&nbsp;&nbsp; 时间复杂度为：<strong>T(N)=T(N/2)+T(N/2)+O(N)，即T(N)=O(NlogN)。</strong></p><p><strong>2.统一函数接口</strong></p><p style="text-indent:28px">为了与前面的函数接口统一，因此我们需要再写一个函数来统一函数接口。其伪码描述如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Merge_sort(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;*TmpA;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA&nbsp;=&nbsp;malloc(&nbsp;N&nbsp;*&nbsp;sizeof(&nbsp;ElementType&nbsp;)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;TmpA&nbsp;!=&nbsp;NULL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSort(&nbsp;A,&nbsp;TmpA,&nbsp;0,&nbsp;N-1&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(&nbsp;TmpA&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;Error(&nbsp;“空间不足&quot;&nbsp;);
}</pre><p style="text-indent:28px">如果只在Merge中声明临时数组，那么两个子函数声明如下：</p><p>void Merge( ElementType A[], int L, int R, int RightEnd )</p><p>void MSort( ElementType A[], int L, int RightEnd )</p><p>&nbsp;&nbsp;&nbsp; 这样也不是不行，但是这样的话，<strong>每一次在子函数里面用一次释放一次，增加了时间复杂度，还不如直接在最外层的代码里面定义好。</strong></p><p style="text-indent:28px"><strong>整体的源代码实现如下：</strong></p><pre class="brush:cpp;toolbar:false">/*&nbsp;归并排序&nbsp;-&nbsp;递归实现&nbsp;*/
&nbsp;
/*&nbsp;L&nbsp;=&nbsp;左边起始位置,&nbsp;R&nbsp;=&nbsp;右边起始位置,&nbsp;RightEnd&nbsp;=&nbsp;右边终点位置*/
void&nbsp;Merge(&nbsp;ElementType&nbsp;A[],&nbsp;ElementType&nbsp;TmpA[],&nbsp;int&nbsp;L,&nbsp;int&nbsp;R,&nbsp;int&nbsp;RightEnd&nbsp;)
{&nbsp;/*&nbsp;将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;LeftEnd,&nbsp;NumElements,&nbsp;Tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LeftEnd&nbsp;=&nbsp;R&nbsp;-&nbsp;1;&nbsp;/*&nbsp;左边终点位置&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tmp&nbsp;=&nbsp;L;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;有序序列的起始位置&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumElements&nbsp;=&nbsp;RightEnd&nbsp;-&nbsp;L&nbsp;+&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;L&nbsp;&lt;=&nbsp;LeftEnd&nbsp;&amp;&amp;&nbsp;R&nbsp;&lt;=&nbsp;RightEnd&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;A[L]&nbsp;&lt;=&nbsp;A[R]&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA[Tmp++]&nbsp;=&nbsp;A[L++];&nbsp;/*&nbsp;将左边元素复制到TmpA&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA[Tmp++]&nbsp;=&nbsp;A[R++];&nbsp;/*&nbsp;将右边元素复制到TmpA&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;L&nbsp;&lt;=&nbsp;LeftEnd&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA[Tmp++]&nbsp;=&nbsp;A[L++];&nbsp;/*&nbsp;直接复制左边剩下的&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;R&nbsp;&lt;=&nbsp;RightEnd&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA[Tmp++]&nbsp;=&nbsp;A[R++];&nbsp;/*&nbsp;直接复制右边剩下的&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;NumElements;&nbsp;i++,&nbsp;RightEnd&nbsp;--&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[RightEnd]&nbsp;=&nbsp;TmpA[RightEnd];&nbsp;/*&nbsp;将有序的TmpA[]复制回A[]&nbsp;*/
}
&nbsp;
void&nbsp;Msort(&nbsp;ElementType&nbsp;A[],&nbsp;ElementType&nbsp;TmpA[],&nbsp;int&nbsp;L,&nbsp;int&nbsp;RightEnd&nbsp;)
{&nbsp;/*&nbsp;核心递归排序函数&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Center;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;L&nbsp;&lt;&nbsp;RightEnd&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Center&nbsp;=&nbsp;(L+RightEnd)&nbsp;/&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Msort(&nbsp;A,&nbsp;TmpA,&nbsp;L,&nbsp;Center&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;递归解决左边&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Msort(&nbsp;A,&nbsp;TmpA,&nbsp;Center+1,&nbsp;RightEnd&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;递归解决右边&nbsp;*/&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge(&nbsp;A,&nbsp;TmpA,&nbsp;L,&nbsp;Center+1,&nbsp;RightEnd&nbsp;);&nbsp;&nbsp;/*&nbsp;合并两段有序序列&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}
&nbsp;
void&nbsp;MergeSort(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{&nbsp;/*&nbsp;归并排序&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;*TmpA;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA&nbsp;=&nbsp;(ElementType&nbsp;*)malloc(N*sizeof(ElementType));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;TmpA&nbsp;!=&nbsp;NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Msort(&nbsp;A,&nbsp;TmpA,&nbsp;0,&nbsp;N-1&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(&nbsp;TmpA&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;printf(&nbsp;&quot;空间不足&quot;&nbsp;);
}</pre><h3><span style="font-weight:normal">9.5.3 </span><span style="font-weight:normal">非递归算法</span></h3><p style="text-indent:28px">非递归算法的图示如图3所示。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180512/1526113355712562.jpg" title="1526113355712562.jpg" alt="1526113355712562.jpg" width="390" height="195"/>&nbsp;</p><p style="text-align:center">图3</p><p style="text-indent:28px">额外空间复杂度是<strong>O(N)</strong>。我们只需要开一个临时数组就可以了，没必要每次都开一个。</p><p style="text-indent:28px">其伪码描述如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Merge_pass(&nbsp;ElementType&nbsp;A[],&nbsp;ElementType&nbsp;TmpA[],&nbsp;int&nbsp;N,int&nbsp;length&nbsp;)
&nbsp;/*&nbsp;length&nbsp;=&nbsp;当前有序子列的长度*/
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=0;&nbsp;i&nbsp;&lt;=&nbsp;N–2*length;&nbsp;i&nbsp;+=&nbsp;2*length&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge1(&nbsp;A,&nbsp;TmpA,&nbsp;i,&nbsp;i+length,&nbsp;i+2*length–1&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;i+length&nbsp;&lt;&nbsp;N&nbsp;)&nbsp;/*&nbsp;归并最后2个子列*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge1(&nbsp;A,&nbsp;TmpA,&nbsp;i,&nbsp;i+length,&nbsp;N–1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;/*&nbsp;最后只剩1个子列*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&lt;&nbsp;N;&nbsp;j++&nbsp;)&nbsp;TmpA[j]&nbsp;=&nbsp;A[j];
}</pre><p style="text-indent:28px">统一接口如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Merge_sort(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;length&nbsp;=&nbsp;1;&nbsp;/*&nbsp;初始化子序列长度*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;*TmpA;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA&nbsp;=&nbsp;malloc(&nbsp;N&nbsp;*&nbsp;sizeof(&nbsp;ElementType&nbsp;)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;TmpA&nbsp;!=&nbsp;NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;length&nbsp;&lt;&nbsp;N&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge_pass(&nbsp;A,&nbsp;TmpA,&nbsp;N,&nbsp;length&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;*=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge_pass(&nbsp;TmpA,&nbsp;A,&nbsp;N,&nbsp;length&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;*=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(&nbsp;TmpA&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;Error(&nbsp;“空间不足&quot;&nbsp;);
}</pre><p style="text-indent:28px"><strong>具有稳定性！</strong></p><p style="text-indent:28px"><strong><span style="color:red">缺点是需要额外空间之类的~此方法主要用在外排序。</span></strong></p><p style="text-indent:28px"><strong>C语言实现源代码：</strong></p><pre class="brush:cpp;toolbar:false">/*&nbsp;归并排序&nbsp;-&nbsp;循环实现&nbsp;*/
/*&nbsp;这里Merge函数在递归版本中给出&nbsp;*/
&nbsp;
/*&nbsp;length&nbsp;=&nbsp;当前有序子列的长度*/
void&nbsp;Merge_pass(&nbsp;ElementType&nbsp;A[],&nbsp;ElementType&nbsp;TmpA[],&nbsp;int&nbsp;N,&nbsp;int&nbsp;length&nbsp;)
{&nbsp;/*&nbsp;两两归并相邻有序子列&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i=0;&nbsp;i&nbsp;&lt;=&nbsp;N-2*length;&nbsp;i&nbsp;+=&nbsp;2*length&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge(&nbsp;A,&nbsp;TmpA,&nbsp;i,&nbsp;i+length,&nbsp;i+2*length-1&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;i+length&nbsp;&lt;&nbsp;N&nbsp;)&nbsp;/*&nbsp;归并最后2个子列*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge(&nbsp;A,&nbsp;TmpA,&nbsp;i,&nbsp;i+length,&nbsp;N-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;/*&nbsp;最后只剩1个子列*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&lt;&nbsp;N;&nbsp;j++&nbsp;)&nbsp;TmpA[j]&nbsp;=&nbsp;A[j];
}
&nbsp;
void&nbsp;Merge_Sort(&nbsp;ElementType&nbsp;A[],&nbsp;int&nbsp;N&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;*TmpA;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;=&nbsp;1;&nbsp;/*&nbsp;初始化子序列长度*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TmpA&nbsp;=&nbsp;malloc(&nbsp;N&nbsp;*&nbsp;sizeof(&nbsp;ElementType&nbsp;)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;TmpA&nbsp;!=&nbsp;NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;length&nbsp;&lt;&nbsp;N&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge_pass(&nbsp;A,&nbsp;TmpA,&nbsp;N,&nbsp;length&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;*=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge_pass(&nbsp;TmpA,&nbsp;A,&nbsp;N,&nbsp;length&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;*=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(&nbsp;TmpA&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;printf(&nbsp;&quot;空间不足&quot;&nbsp;);
}</pre><p><br/></p>
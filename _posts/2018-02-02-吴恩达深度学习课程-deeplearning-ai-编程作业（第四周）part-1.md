---
ID: 3563
post_title: >
  吴恩达深度学习课程
  DeepLearning.ai
  编程作业（1-4）Part.1
post_name: '%e5%90%b4%e6%81%a9%e8%be%be%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e8%af%be%e7%a8%8b-deeplearning-ai-%e7%bc%96%e7%a8%8b%e4%bd%9c%e4%b8%9a%ef%bc%88%e7%ac%ac%e5%9b%9b%e5%91%a8%ef%bc%89part-1'
author: 小奥
post_date: 2018-02-02 18:32:39
layout: post
link: >
  http://www.yushuai.me/2018/02/02/3563.html
published: true
tags:
  - Python
  - 深度学习
  - 神经网络
categories:
  - Deep Learning
---
<h1 style="font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; margin: 8px 0px 16px; padding: 0px; box-sizing: border-box; color: rgb(79, 79, 79); font-size: 28px; line-height: 36px; white-space: normal; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box;">Part 1：Building your Deep Neural Network: Step by Step</span></h1><h2 style="font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; margin: 8px 0px 16px; padding: 0px; box-sizing: border-box; color: rgb(79, 79, 79); font-size: 24px; line-height: 32px; white-space: normal; background-color: rgb(255, 255, 255);"><a style="color: rgb(78, 161, 219); outline: 0px; margin: 0px; padding: 0px; font-weight: 400; box-sizing: border-box;"></a>1 - Packages</h2><p style="margin-top: 0px; margin-bottom: 16px; padding: 0px; box-sizing: border-box; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; white-space: normal; background-color: rgb(255, 255, 255);">Let’s first import all the packages that you will need duri</p><p style="margin-top: 0px; margin-bottom: 16px; padding: 0px; box-sizing: border-box; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; white-space: normal; background-color: rgb(255, 255, 255);">ng this assignment.&nbsp;<br/>-&nbsp;<a href="http://www.numpy.org" target="_blank">numpy</a>&nbsp;is the main package for scientific computing with Python.&nbsp;<br/>-&nbsp;<a href="http://matplotlib.org/" target="_blank" style="color: rgb(103, 149, 181); outline: 0px; margin: 0px; padding: 0px; box-sizing: border-box; text-decoration-line: none;">matplotlib</a>&nbsp;is a library to plot graphs in Python.&nbsp;<br/>- dnn_utils provides some necessary functions for this notebook.&nbsp;<br/>- testCases provides some test cases to assess the correctness of your functions&nbsp;<br/>- np.random.seed(1) is used to keep all the random function calls consistent. It will help us grade your work. Please don’t change the seed.</p><pre class="brush:python;toolbar:false">import&nbsp;numpy&nbsp;as&nbsp;np
import&nbsp;h5py
import&nbsp;matplotlib.pyplot&nbsp;as&nbsp;plt
from&nbsp;testCases_v3&nbsp;import&nbsp;*
from&nbsp;dnn_utils_v2&nbsp;import&nbsp;sigmoid,&nbsp;sigmoid_backward,&nbsp;relu,&nbsp;relu_backward
%matplotlib&nbsp;inline
plt.rcParams[&#39;figure.figsize&#39;]&nbsp;=&nbsp;(5.0,&nbsp;4.0)&nbsp;#&nbsp;set&nbsp;default&nbsp;size&nbsp;of&nbsp;plots
plt.rcParams[&#39;image.interpolation&#39;]&nbsp;=&nbsp;&#39;nearest&#39;
plt.rcParams[&#39;image.cmap&#39;]&nbsp;=&nbsp;&#39;gray&#39;
%load_ext&nbsp;autoreload
%autoreload&nbsp;2
np.random.seed(1)</pre><p style="margin-top:auto;margin-bottom: auto;text-align:left"><strong><span style="font-size:24px;font-family:宋体">2 – </span></strong><strong><span style="font-size:24px;font-family:宋体">大作业框架</span></strong></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">To build your neural network, you will be implementing several &quot;helper functions&quot;. These helper functions will be used in the next assignment to build a two-layer neural network and an L-layer neural network. Each small helper function you will implement will have detailed instructions that will walk you through the necessary steps. Here is an outline of this assignment, you will:</span></p><ul class=" list-paddingleft-2"><li><p><span style="font-size:16px;font-family:宋体">Initialize &nbsp; &nbsp; &nbsp;the parameters for a two-layer network and for an </span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">L</span></em><span style="font-size:16px;font-family:宋体">-layer neural network.</span><span style="font-size:16px;font-family:宋体">（初始化2层和L层神经网络的参数）</span></p></li><li><p><span style="font-size:16px;font-family:宋体">Implement the &nbsp; &nbsp; &nbsp;forward propagation module (shown in purple in the figure below).</span><span style="font-size:16px;font-family:宋体">（进行前向传播模型）</span></p></li><ul style="list-style-type: square;" class=" list-paddingleft-2"><li><p><span style="font-size:16px;font-family:宋体">Complete the &nbsp; &nbsp; &nbsp; LINEAR part of a layer&#39;s forward propagation step (resulting in </span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">Z</span></em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">[<em>l</em>]</span><span style="font-size:16px;font-family:宋体">).</span><span style="font-size:16px;font-family:宋体">（完成一层前向传播的线性部分）</span></p></li><li><p><span style="font-size:16px;font-family:宋体">我们给你了激活函数(relu/sigmoid).</span></p></li><li><p><span style="font-size:16px;font-family:宋体">将之前的两步混合加入一个新的【线性-&gt;激活】前向传递函数。</span></p></li><li><p><span style="font-size:16px;font-family:宋体">堆叠【线性-&gt;激活】前向传递函数并且增加一个【线性-&gt;SIGMOID】在最后一层。这完成了一个新的L_model前向传播函数。</span></p></li></ul><li><p><span style="font-size:16px;font-family:宋体">计算损失函数.</span></p></li><li><p><span style="font-size:16px;font-family:宋体">Implement the &nbsp; &nbsp; &nbsp;backward propagation module (denoted in red in the figure below).</span><span style="font-size:16px;font-family:宋体">进行反向传播模型</span></p></li><ul style="list-style-type: square;" class=" list-paddingleft-2"><li><p><span style="font-size:16px;font-family:宋体">Complete the &nbsp; &nbsp; &nbsp; LINEAR part of a layer&#39;s backward propagation step.</span></p></li><li><p><span style="font-size:16px;font-family:宋体">We give you &nbsp; &nbsp; &nbsp; the gradient of the ACTIVATE function (relu_backward/sigmoid_backward) </span></p></li><li><p><span style="font-size:16px;font-family:宋体">Combine the &nbsp; &nbsp; &nbsp; previous two steps into a new [LINEAR-&gt;ACTIVATION] backward function.</span></p></li><li><p><span style="font-size:16px;font-family:宋体">Stack &nbsp; &nbsp; &nbsp; [LINEAR-&gt;RELU] backward L-1 times and add [LINEAR-&gt;SIGMOID] &nbsp; &nbsp; &nbsp; backward in a new L_model_backward function</span></p></li></ul><li><p><span style="font-size:16px;font-family:宋体">Finally update the parameters.</span></p></li></ul><p style="text-align: center;"><span style="font-family: Consolas, Inconsolata, Courier, monospace; font-size: 14px; white-space: pre; background-color: #F6F8FA;"><img src="/wp-content/uploads/image/20180202/1517584310140726.jpg" title="1517584310140726.jpg" alt="1517584310140726.jpg" width="405" height="300"/><br/></span></p><p><span style="font-family: Consolas, Inconsolata, Courier, monospace; font-size: 14px; white-space: pre; background-color: #F6F8FA;"></span></p><p>注意：对于每个前向函数，都有一个相应的反向函数。 这就是为什么在你的前向模块的每一步你都会在缓存中存储一些值。 缓存的值对于计算梯度非常有用。 在反向传播模块中，您将使用缓存来计算梯度。 这项任务将向您显示如何执行每个步骤。</p><h2>3 – 初始化</h2><p>本部分你将写出两个子函数来初始化你的模型的参数。第一个函数被用来初始化两层模型的参数，第二个用来初始化L层模型的参数。</p><h3>3.1 - 2层神经网络</h3><p><strong><span style="font-family:宋体">Exercise</span></strong>: Create and initialize the parameters of the 2-layer neural network.</p><p><strong><span style="font-family:宋体">Instructions</span></strong>:</p><ul class=" list-paddingleft-2"><li><p>The model&#39;s structure is: <em><span style="font-family:等线">LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID</span></em>.</p></li><li><p>Use random initialization for the weight matrices. Use <code><span style="font-size:16px">np.random.randn(shape)*0.01</span></code> with the correct shape.</p></li><li><p>Use zero initialization for the biases. Use <code><span style="font-size:16px">np.zeros(shape)</span></code>.</p></li></ul><p><strong>本部分代码在第三周作业已经完成，在此不再累述。</strong></p><h3>3.2 - L层神经网络</h3><p>The initialization for a deeper L-layer neural network is more complicated because there are many more weight matrices and bias vectors. When completing the <code>initialize_parameters_deep</code>, 你应当确保你的维度符合每一层的维度. 调用的 <span style="display:inline-block"><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.237em, 1001.25em, 2.449em, -1000em)"><span style="display:inline-block"><span style="clip:rect(3.369em, 1000.47em, 4.176em, -1000em)">n</span></span></span></span></span></em></span>[<em><span style="font-size: 13px;font-family:&#39;STIXMathJax_Main&#39;,serif">l</span></em>]是l层中每一个节点（单元）的个数。 Thus for example if the size of our input <em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="color:inherit"><span style="display:inline-block"><span style="clip:rect(1.549em, 1000.66em, 2.56em, -1000em)">X</span></span></span></span></span></em>is <span style="color:inherit"><span style="display:inline-block"><span style="display:inline-block"><span style="clip:rect(1.705em, 1005.07em, 2.915em, -1000em)">(12288,209)</span> (with <span style="color:inherit"></span></span></span><span style="display:inline-block"><span style="display:inline-block"><span style="clip:rect(1.705em, 1003.47em, 2.76em, -1000em)">m=209</span> examples) then:</span> </span></span></p><p style="text-align: center;"><span style="font-family: Consolas, Inconsolata, Courier, monospace; font-size: 14px; white-space: pre; background-color: #F6F8FA;"><img src="/wp-content/uploads/image/20180202/1517584590120928.jpg" title="1517584590120928.jpg" alt="1517584590120928.jpg" width="480" height="85"/><br/></span></p><p><span style="font-family: Consolas, Inconsolata, Courier, monospace; font-size: 14px; white-space: pre; background-color: #F6F8FA;"></span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><strong><span style="font-size:16px;font-family:宋体">Exercise</span></strong><span style="font-size:16px;font-family: 宋体">: Implement initialization for an L-layer Neural Network. </span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><strong><span style="font-size:16px;font-family:宋体">Instructions</span></strong><span style="font-size:16px;font-family:宋体">:</span></p><ul class=" list-paddingleft-2"><li><p><span style="font-size:16px;font-family:宋体">The model&#39;s structure is <em>[LINEAR -&gt; RELU] </em></span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">×</span></em><em><span style="font-size:16px;font-family:宋体">(L-1) -&gt; LINEAR -&gt; SIGMOID</span></em><span style="font-size:16px;font-family:宋体">. I.e., it has </span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">L</span></em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">−1</span><span style="font-size:16px;font-family:宋体"> layers using a ReLU activation function followed by an output layer with a sigmoid activation function.</span></p></li><li><p><span style="font-size:16px;font-family:宋体">Use random initialization for the weight matrices. Use np.random.rand(shape) * 0.01.</span></p></li><li><p><span style="font-size:16px;font-family:宋体">Use zeros initialization for the biases. Use np.zeros(shape).</span></p></li><li><p><span style="font-size:16px;font-family:宋体">We will store </span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">n</span></em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">[<em>l</em>]</span><span style="font-size:16px;font-family:宋体">, the number of units in different layers, in a variable layer_dims. For example, the layer_dims for the &quot;Planar Data classification model&quot; from last week would have been [2,4,1]: There were two inputs, one hidden layer with 4 hidden units, and an output layer with 1 output unit. Thus means W1&#39;s shape was (4,2), b1 was (4,1), W2 was (1,4) and b2 was (1,1). Now you will generalize this to </span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">L</span></em><span style="font-size:16px;font-family:宋体"> layers! </span></p></li><li><p><span style="font-size:16px;font-family:宋体">Here is the implementation for </span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">L</span></em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">=1</span><span style="font-size:16px;font-family:宋体"> (one layer neural network). It should inspire you to implement the general case (L-layer neural network).</span></p></li></ul><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体"></span></p><pre class="brush:python;toolbar:false">if&nbsp;L&nbsp;==&nbsp;1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters[&quot;W&quot;&nbsp;+&nbsp;str(L)]&nbsp;=&nbsp;np.random.randn(layer_dims[1],&nbsp;layer_dims[0])&nbsp;*&nbsp;0.01
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters[&quot;b&quot;&nbsp;+&nbsp;str(L)]&nbsp;=&nbsp;np.zeros((layer_dims[1],&nbsp;1))</pre><pre class="brush:python;toolbar:false">#&nbsp;GRADED&nbsp;FUNCTION:&nbsp;initialize_parameters_deep
&nbsp;
def&nbsp;initialize_parameters_deep(layer_dims):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;Arguments:
&nbsp;&nbsp;&nbsp;&nbsp;layer_dims&nbsp;--&nbsp;python&nbsp;array&nbsp;(list)&nbsp;containing&nbsp;the&nbsp;dimensions&nbsp;of&nbsp;each&nbsp;layer&nbsp;in&nbsp;our&nbsp;network
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Returns:
&nbsp;&nbsp;&nbsp;&nbsp;parameters&nbsp;--&nbsp;python&nbsp;dictionary&nbsp;containing&nbsp;your&nbsp;parameters&nbsp;&quot;W1&quot;,&nbsp;&quot;b1&quot;,&nbsp;...,&nbsp;&quot;WL&quot;,&nbsp;&quot;bL&quot;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wl&nbsp;--&nbsp;weight&nbsp;matrix&nbsp;of&nbsp;shape&nbsp;(layer_dims[l],&nbsp;layer_dims[l-1])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bl&nbsp;--&nbsp;bias&nbsp;vector&nbsp;of&nbsp;shape&nbsp;(layer_dims[l],&nbsp;1)
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;np.random.seed(3)
&nbsp;&nbsp;&nbsp;&nbsp;parameters&nbsp;=&nbsp;{}
&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;len(layer_dims)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;number&nbsp;of&nbsp;layers&nbsp;in&nbsp;the&nbsp;network
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;l&nbsp;in&nbsp;range(1,&nbsp;L):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;2&nbsp;lines&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters[&#39;W&#39;&nbsp;+&nbsp;str(l)]&nbsp;=&nbsp;np.random.randn(layer_dims[l],layer_dims[l-1])*0.01
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters[&#39;b&#39;&nbsp;+&nbsp;str(l)]&nbsp;=&nbsp;np.zeros((layer_dims[l],1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters[&#39;W&#39;&nbsp;+&nbsp;str(l)].shape&nbsp;==&nbsp;(layer_dims[l],&nbsp;layer_dims[l-1]))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(parameters[&#39;b&#39;&nbsp;+&nbsp;str(l)].shape&nbsp;==&nbsp;(layer_dims[l],&nbsp;1))&nbsp;
return&nbsp;parameters</pre><p style="margin-top:auto;margin-bottom: auto;text-align:left"><br/></p><h2>4 – 前向传播模型</h2><h3>4.1 – 线性前向传播</h3><p>Now that you have initialized your parameters, you will do the forward propagation module. You will start by implementing some basic functions that you will use later when implementing the model. You will complete three functions in this order:</p><ul class=" list-paddingleft-2"><li><p>LINEAR</p></li><li><p>LINEAR -&gt; ACTIVATION where &nbsp; &nbsp; &nbsp;ACTIVATION will be either ReLU or Sigmoid.</p></li><li><p>[LINEAR -&gt; RELU] <span style="display:inline-block"><span style="font-size:19px;font-family:      &#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.852em, 1000.61em, 2.763em, -1000em)">×</span><span style="display:inline-block"></span></span></span></span>× (L-1) -&gt; LINEAR -&gt; SIGMOID (whole model)</p></li></ul><p>The linear forward module (vectorized over all the examples) computes the following equations:</p><p style="text-align:center"><span style="display:inline-block;min-width: 13.199em"><em><span style="font-size:19px;font-family: &#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block;min-width: 13.199em"><span style="clip:rect(3.012em, 1009.07em, 4.465em, -1000em)"><span style="min-width: 13.199em"><span style="display:inline-block;min-width: 13.199em"><span style="display:inline-block;clip:rect(-0.976em, 1009.07em, 0.476em, -1000em)"><span style="clip:rect(3.012em, 1009.07em, 4.306em, -1000em)"><span style="display:inline-block"><span style="clip:rect(2.914em, 1009.07em, 4.208em, -1000em)"><span style="display:inline-block"><span style="clip:rect(3.157em, 1000.61em, 4.167em, -1000em)">Z</span></span></span></span></span></span></span></span></span></span></span></em></span>[<em><sup><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">l</span></sup></em><sup>]</sup>=<span style="display:inline-block"><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="clip:rect(3.157em, 1000.91em, 4.185em, -1000em)">W</span></span></em></span>[<em><sup><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">l</span></sup></em><sup>]</sup><em><span style="display:inline-block"><span style="clip:rect(3.142em, 1000.56em, 4.167em, -1000em)">A</span></span></em><sup>[</sup><em><sup><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">l</span></sup></em><sup>−</sup><sup><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">1</span></sup><sup><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">]</span></sup>+<span style="display:inline-block"><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="clip:rect(3.127em, 1000.47em, 4.178em, -1000em)">b</span></span></em></span><sup>[</sup><em><sup><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">l</span></sup></em><sup>]</sup></p><p><span style="display:inline-block;clip:rect(-0.757em, 1001.12em, 0.453em, -1000em);right:0em"><span style="clip:rect(3.134em, 1001.12em, 4.344em, -1000em);right:0em"> </span></span></p><p>where <span style="display:inline-block"><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.54em, 1003.45em, 2.738em, -1000em)"><span style="display:inline-block"><span style="clip:rect(3.142em, 1000.56em, 4.167em, -1000em)">A</span></span></span></span></span></em></span>[<span style="font-size: 13px;font-family:&#39;STIXMathJax_Main&#39;,serif">0</span><span style="font-size: 13px;font-family:&#39;STIXMathJax_Main&#39;,serif">]</span>=<em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">X</span></em></p><p><strong><span style="font-family:宋体">Exercise</span></strong>: Build the linear part of forward propagation.</p><p><strong><span style="font-family:宋体">Reminder</span></strong>: The mathematical representation of this unit is <span style="display:inline-block"><em><span style="font-size:19px;font-family: &#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.535em, 1009.05em, 2.779em, -1000em)"><span style="display:inline-block"><span style="clip:rect(3.157em, 1000.61em, 4.167em, -1000em)">Z[l]=W[l]A[l−1]+b[l]</span></span></span></span></span></em></span>. You may also find <code>np.dot()</code> useful. If your dimensions don&#39;t match, printing <code>W.shape</code> may help.</p><pre class="brush:python;toolbar:false">#&nbsp;GRADED&nbsp;FUNCTION:&nbsp;linear_forward
&nbsp;
def&nbsp;linear_forward(A,&nbsp;W,&nbsp;b):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;Implement&nbsp;the&nbsp;linear&nbsp;part&nbsp;of&nbsp;a&nbsp;layer&#39;s&nbsp;forward&nbsp;propagation.
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Arguments:
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;--&nbsp;activations&nbsp;from&nbsp;previous&nbsp;layer&nbsp;(or&nbsp;input&nbsp;data):&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(size&nbsp;of&nbsp;previous&nbsp;layer,&nbsp;number&nbsp;of&nbsp;examples)
&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;--&nbsp;weights&nbsp;matrix:&nbsp;numpy&nbsp;array&nbsp;of&nbsp;shape&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(size&nbsp;of&nbsp;current&nbsp;layer,&nbsp;size&nbsp;of&nbsp;previous&nbsp;layer)
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;--&nbsp;bias&nbsp;vector,&nbsp;numpy&nbsp;array&nbsp;of&nbsp;shape&nbsp;(size&nbsp;of&nbsp;the&nbsp;current&nbsp;layer,&nbsp;1)
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Returns:
&nbsp;&nbsp;&nbsp;&nbsp;Z&nbsp;--&nbsp;the&nbsp;input&nbsp;of&nbsp;the&nbsp;activation&nbsp;function,&nbsp;also&nbsp;called&nbsp;pre-activation&nbsp;parameter
&nbsp;&nbsp;&nbsp;&nbsp;cache&nbsp;--&nbsp;a&nbsp;python&nbsp;dictionary&nbsp;containing&nbsp;&quot;A&quot;,&nbsp;&quot;W&quot;&nbsp;and&nbsp;&quot;b&quot;&nbsp;;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;stored&nbsp;for&nbsp;computing&nbsp;the&nbsp;backward&nbsp;pass&nbsp;efficiently
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;1&nbsp;line&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;Z&nbsp;=&nbsp;np.dot(W,A)&nbsp;+&nbsp;b
&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;assert(Z.shape&nbsp;==&nbsp;(W.shape[0],&nbsp;A.shape[1]))
&nbsp;&nbsp;&nbsp;&nbsp;cache&nbsp;=&nbsp;(A,&nbsp;W,&nbsp;b)
&nbsp;&nbsp;&nbsp;
return&nbsp;Z,&nbsp;cache</pre><h3>4.2 -线性激活函数前向传播</h3><p>In this notebook, you will use two activation functions:</p><ul class=" list-paddingleft-2"><li><p><strong><span style="font-family:等线">Sigmoid</span></strong>: <span style="display:inline-block"><span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.316em 1000em 3.019em -0.387em)">σ(<span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">Z</span>)=<span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">σ</span>(<span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">W</span>A<span style="font-size:22px;font-family:&#39;MathJax_Main&#39;,serif">+</span><span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">b</span><span style="font-size:22px;font-family:&#39;MathJax_Main&#39;,serif">)</span>=<span style="display:inline-block"><span style="font-size:15px;font-family:&#39;MathJax_Main&#39;,serif"><span style="clip:rect(1.706em 1000em 2.484em -0.387em)">1</span><span style="clip:rect(1.608em 1000em 2.533em -0.387em)">1<span style="font-size:15px;font-family:&#39;MathJax_Main&#39;,serif">+</span><span style="display:inline-block"><span style="font-size:15px;font-family:&#39;MathJax_Math-italic&#39;,serif"><span style="clip:rect(1.9em 1000em 2.484em -0.387em)">e</span>−(<span style="font-size:11px;font-family:&#39;MathJax_Math-italic&#39;,serif">W</span>A<span style="font-size:11px;font-family:&#39;MathJax_Main&#39;,serif">+</span><span style="font-size:11px;font-family:&#39;MathJax_Math-italic&#39;,serif">b</span><span style="font-size:11px;font-family:&#39;MathJax_Main&#39;,serif">)</span></span></span></span></span></span></span></span></span></span>. &nbsp; &nbsp; &nbsp;We have provided you with the <code><span style="font-size:16px">sigmoid</span></code> function. &nbsp; &nbsp; &nbsp;This function returns <strong><span style="font-family:等线">two</span></strong> items: the activation &nbsp; &nbsp; &nbsp;value “<code><span style="font-size:16px">a</span></code>” and a “<code><span style="font-size:16px">cache</span></code>” that contains “<code><span style="font-size:16px">Z</span></code>” (it’s what we &nbsp; &nbsp; &nbsp;will feed in to the corresponding backward function). To use it you could &nbsp; &nbsp; &nbsp;just call:</p></li></ul><pre class="brush:python;toolbar:false;">A,&nbsp;activation_cache&nbsp;=&nbsp;sigmoid(Z)</pre><p><br/></p><ul class=" list-paddingleft-2"><li><p><strong><span style="font-family:等线">ReLU</span></strong>:（修正线性单元） The mathematical formula for ReLu is <span style="display:inline-block"><span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.462em 1000em 2.727em -0.387em)">A<span style="font-size:22px;font-family:&#39;MathJax_Main&#39;,serif">=</span><span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">R</span>ELU(<span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">Z</span>)=<span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">m</span>ax<span style="font-size:22px;font-family:&#39;MathJax_Main&#39;,serif">(</span><span style="font-size:22px;font-family:&#39;MathJax_Main&#39;,serif">0</span><span style="font-size:22px;font-family:&#39;MathJax_Main&#39;,serif">,</span><span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">Z</span>)</span><span style="display:      inline-block"></span></span></span></span>. &nbsp; &nbsp; &nbsp;We have provided you with the <code><span style="font-size:16px">relu</span></code> function. &nbsp; &nbsp; &nbsp;This function returns <strong><span style="font-family:等线">two</span></strong> items: the activation &nbsp; &nbsp; &nbsp;value “<code><span style="font-size:16px">A</span></code>” and a “<code><span style="font-size:16px">cache</span></code>” that contains “<code><span style="font-size:16px">Z</span></code>” (it’s what we &nbsp; &nbsp; &nbsp;will feed in to the corresponding backward function). To use it you could &nbsp; &nbsp; &nbsp;just call:</p></li></ul><pre class="brush:python;toolbar:false;">A,&nbsp;activation_cache&nbsp;=&nbsp;relu(Z)</pre><p><br/></p><p>For more convenience, you are going to group two functions (Linear and Activation) into one function (LINEAR-&gt;ACTIVATION). Hence, you will implement a function that does the LINEAR forward step followed by an ACTIVATION forward step.</p><p><strong><span style="font-family:宋体">Exercise</span></strong>: Implement the forward propagation of the <em><span style="font-family:宋体">LINEAR-&gt;ACTIVATION</span></em> layer. Mathematical relation is: <span style="display:inline-block"><span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.219em 1000em 2.727em -0.387em)"><span style="display:inline-block"><span style="clip:rect(1.462em 1000em 2.484em -0.387em)">A</span>[<span style="font-size: 15px;font-family:&#39;MathJax_Math-italic&#39;,serif">l</span><span style="font-size: 15px;font-family:&#39;MathJax_Main&#39;,serif">]</span></span>=<span style="font-size:22px;font-family:&#39;MathJax_Math-italic&#39;,serif">g</span>(<span style="display:inline-block"><span style="font-size: 22px;font-family:&#39;MathJax_Math-italic&#39;,serif"><span style="clip:rect(1.511em 1000em 2.484em -0.387em)">Z</span>[<span style="font-size: 15px;font-family:&#39;MathJax_Math-italic&#39;,serif">l</span><span style="font-size: 15px;font-family:&#39;MathJax_Main&#39;,serif">]</span></span></span>)=<span style="font-size: 22px;font-family:&#39;MathJax_Math-italic&#39;,serif">g</span>(<span style="display:inline-block"><span style="font-size: 22px;font-family:&#39;MathJax_Math-italic&#39;,serif"><span style="clip:rect(1.511em 1000em 2.484em -0.387em)">W</span>[<span style="font-size: 15px;font-family:&#39;MathJax_Math-italic&#39;,serif">l</span><span style="font-size: 15px;font-family:&#39;MathJax_Main&#39;,serif">]</span></span></span><span style="display:inline-block"><span style="clip:rect(1.462em 1000em 2.484em -0.387em)">A</span>[<span style="font-size: 15px;font-family:&#39;MathJax_Math-italic&#39;,serif">l</span><span style="font-size: 15px;font-family:&#39;MathJax_Main&#39;,serif">−</span><span style="font-size: 15px;font-family:&#39;MathJax_Main&#39;,serif">1</span><span style="font-size: 15px;font-family:&#39;MathJax_Main&#39;,serif">]</span></span>+<span style="display:inline-block"><span style="font-size: 22px;font-family:&#39;MathJax_Math-italic&#39;,serif"><span style="clip:rect(1.511em 1000em 2.484em -0.387em)">b</span>[<span style="font-size: 15px;font-family:&#39;MathJax_Math-italic&#39;,serif">l</span><span style="font-size: 15px;font-family:&#39;MathJax_Main&#39;,serif">]</span></span></span>)</span><span style="display:inline-block"></span></span></span></span> where the activation “g” can be sigmoid() or relu(). Use linear_forward() and the correct activation function.</p><pre class="brush:python;toolbar:false">#&nbsp;GRADED&nbsp;FUNCTION:&nbsp;linear_activation_forward
&nbsp;
def&nbsp;linear_activation_forward(A_prev,&nbsp;W,&nbsp;b,&nbsp;activation):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;Implement&nbsp;the&nbsp;forward&nbsp;propagation&nbsp;for&nbsp;the&nbsp;LINEAR-&gt;ACTIVATION&nbsp;layer
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Arguments:
&nbsp;&nbsp;&nbsp;&nbsp;A_prev&nbsp;--&nbsp;activations&nbsp;from&nbsp;previous&nbsp;layer&nbsp;(or&nbsp;input&nbsp;data):&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(size&nbsp;of&nbsp;previous&nbsp;layer,&nbsp;number&nbsp;of&nbsp;examples)
&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;--&nbsp;weights&nbsp;matrix:&nbsp;numpy&nbsp;array&nbsp;of&nbsp;shape&nbsp;(size&nbsp;of&nbsp;current&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;layer,&nbsp;size&nbsp;of&nbsp;previous&nbsp;layer)
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;--&nbsp;bias&nbsp;vector,&nbsp;numpy&nbsp;array&nbsp;of&nbsp;shape&nbsp;(size&nbsp;of&nbsp;the&nbsp;current&nbsp;layer,&nbsp;1)
&nbsp;&nbsp;&nbsp;&nbsp;activation&nbsp;--&nbsp;the&nbsp;activation&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;this&nbsp;layer,&nbsp;stored&nbsp;as&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;text&nbsp;string:&nbsp;&quot;sigmoid&quot;&nbsp;or&nbsp;&quot;relu&quot;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Returns:
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;--&nbsp;the&nbsp;output&nbsp;of&nbsp;the&nbsp;activation&nbsp;function,&nbsp;also&nbsp;called&nbsp;the&nbsp;post-activation&nbsp;value
&nbsp;&nbsp;&nbsp;&nbsp;cache&nbsp;--&nbsp;a&nbsp;python&nbsp;dictionary&nbsp;containing&nbsp;&quot;linear_cache&quot;&nbsp;and&nbsp;&quot;activation_cache&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stored&nbsp;for&nbsp;computing&nbsp;the&nbsp;backward&nbsp;pass&nbsp;efficiently
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;activation&nbsp;==&nbsp;&quot;sigmoid&quot;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Inputs:&nbsp;&quot;A_prev,&nbsp;W,&nbsp;b&quot;.&nbsp;Outputs:&nbsp;&quot;A,&nbsp;activation_cache&quot;.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;2&nbsp;lines&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z,&nbsp;linear_cache&nbsp;=&nbsp;linear_forward(A_prev,W,b)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A,&nbsp;activation_cache&nbsp;=&nbsp;sigmoid(Z)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;activation&nbsp;==&nbsp;&quot;relu&quot;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Inputs:&nbsp;&quot;A_prev,&nbsp;W,&nbsp;b&quot;.&nbsp;Outputs:&nbsp;&quot;A,&nbsp;activation_cache&quot;.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;2&nbsp;lines&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z,&nbsp;linear_cache&nbsp;=&nbsp;linear_forward(A_prev,W,b)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A,&nbsp;activation_cache&nbsp;=&nbsp;relu(Z)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(A.shape&nbsp;==&nbsp;(W.shape[0],&nbsp;A_prev.shape[1]))
&nbsp;&nbsp;&nbsp;&nbsp;cache&nbsp;=&nbsp;(linear_cache,&nbsp;activation_cache)
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;A,&nbsp;cache</pre><h3>d) L层模型</h3><p>For even more convenience when implementing the <span style="display:inline-block"><em><span style="font-size:19px;font-family: &#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.549em, 1000.54em, 2.56em, -1000em)">L</span></span></span></em></span>L-layer Neural Net, you will need a function that replicates the previous one (<code>linear_activation_forward</code> with RELU) <span style="display:inline-block"><em><span style="font-size:19px;font-family: &#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.705em, 1002.16em, 2.738em, -1000em)">L</span></span></span></em></span>−<span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">1</span><span style="display:inline-block"></span>L<span style="font-family:&#39;微软雅黑&#39;,sans-serif">−</span>1 times, then follows that with one <code>linear_activation_forward</code> with SIGMOID.</p><p style="margin-top: auto; margin-bottom: auto; text-align: center;"><span style="font-size:16px;font-family:宋体"></span><img src="/wp-content/uploads/image/20180202/1517584950824103.jpg" title="1517584950824103.jpg" alt="1517584950824103.jpg" width="500" height="251"/></p><p style="text-align:center"><strong><span style="font-size:16px;font-family:宋体">Figure 2</span></strong><span style="font-size: 16px;font-family:宋体"> : <em>[LINEAR -&gt; RELU] </em></span><em><span style="font-size:19px;font-family: &#39;STIXMathJax_Main&#39;,serif">×</span></em><em><span style="font-size:16px;font-family:宋体">× (L-1) -&gt; LINEAR -&gt; SIGMOID</span></em><span style="font-size:16px;font-family:宋体"> model</span></p><p style="text-align:left"><span style="font-size:16px;font-family:宋体">&nbsp;</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><strong><span style="font-size:16px;font-family:宋体">Exercise</span></strong><span style="font-size:16px;font-family: 宋体">: Implement the forward propagation of the above model.</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><strong><span style="font-size:16px;font-family:宋体">Instruction</span></strong><span style="font-size:16px;font-family: 宋体">: In the code below, the variable AL will denote </span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">A</span></em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">[<em>L</em>]</span><span style="font-size: 19px;font-family:&#39;STIXMathJax_Main&#39;,serif">=<em>σ</em>(<em>Z</em></span><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">[<em>L</em>]</span><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">)=<em>σ</em>(<em>W</em></span><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">[<em>L</em>]</span><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">A</span></em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">[<em>L</em>−1]</span><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">+<em>b</em></span><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">[<em>L</em>]</span><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">)</span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">. (This is sometimes also called Yhat, i.e., this is Y^.) </span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><strong><span style="font-size:16px;font-family:宋体">Tips</span></strong><span style="font-size:16px;font-family:宋体">:</span></p><ul class=" list-paddingleft-2"><li><p><span style="font-size:16px;font-family:宋体">Use the functions &nbsp; &nbsp; &nbsp;you had previously written </span></p></li><li><p><span style="font-size:16px;font-family:宋体">Use a for &nbsp; &nbsp; &nbsp;loop to replicate [LINEAR-&gt;RELU] (L-1) times</span></p></li><li><p><span style="font-size:16px;font-family:宋体">Don&#39;t forget &nbsp; &nbsp; &nbsp;to keep track of the caches in the &quot;caches&quot; list. To add a new &nbsp; &nbsp; &nbsp;value c to a list, you can use list.append(c).</span></p></li></ul><h2>5 – 代价函数</h2><p>Now you will implement forward and backward propagation. You need to compute the cost, because you want to check if your model is actually learning.</p><p><strong><span style="font-family:宋体">Exercise</span></strong>: Compute the cross-entropy cost <span style="display:inline-block"><em><span style="font-size:19px;font-family: &#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.549em, 1000.48em, 2.578em, -1000em)">J</span></span></span></em></span>J, using the following formula:</p><p style="margin-top:auto;margin-bottom: auto;text-align:center"><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">−</span><span style="display:inline-block"><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="clip:rect(3.134em, 1000.39em, 4.167em, -1000em)">1</span><em><span style="clip:rect(3.369em, 1000.7em, 4.176em, -1000em)">m</span></em></span></span><span style="display:inline-block"><span style="clip:rect(2.835em, 1001.2em, 4.642em, -1000em)"><span style="vertical-align:-.524em">∑</span></span><em><span style="clip:rect(3.332em, 1000.96em, 4.274em, -1000em)">i</span></em></span><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">=</span><span style="font-size: 13px;font-family:&#39;STIXMathJax_Main&#39;,serif">1</span><em><span style="clip:rect(3.398em, 1000.5em, 4.173em, -1000em)">m</span></em><span style="display:inline-block"></span>(<span style="display:inline-block"><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="clip:rect(3.369em, 1000.43em, 4.373em, -1000em)">y</span></span></em></span>(<em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">i</span></em><span style="font-size: 13px;font-family:&#39;STIXMathJax_Main&#39;,serif">)</span>log<span style="font-size:19px;font-family:&#39;STIXMathJax_Size1&#39;,serif"><span style="vertical-align:-.201em">(</span><span style="display:inline-block"><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="clip:rect(3.369em, 1000.48em, 4.178em, -1000em)">a</span></span></em></span>[<em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">L</span></em>](<em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">i</span></em><span style="font-size: 13px;font-family:&#39;STIXMathJax_Main&#39;,serif">)</span></span><span style="vertical-align:-.201em">)</span><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">+(</span><span style="font-size: 19px;font-family:&#39;STIXMathJax_Main&#39;,serif">1</span><span style="font-size: 19px;font-family:&#39;STIXMathJax_Main&#39;,serif">−</span><span style="display:inline-block"><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="clip:rect(3.369em, 1000.43em, 4.373em, -1000em)">y</span></span></em></span>(<em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">i</span></em><span style="font-size: 13px;font-family:&#39;STIXMathJax_Main&#39;,serif">)</span>)<span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">log</span><span style="font-size:19px;font-family:&#39;STIXMathJax_Size1&#39;,serif"><span style="vertical-align:-.201em">(</span><span style="font-size: 19px;font-family:&#39;STIXMathJax_Main&#39;,serif">1</span><span style="font-size: 19px;font-family:&#39;STIXMathJax_Main&#39;,serif">−</span><span style="display:inline-block"><em><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif"><span style="clip:rect(3.369em, 1000.48em, 4.178em, -1000em)">a</span></span></em></span>[<em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">L</span></em>](<em><span style="font-size:13px;font-family:&#39;STIXMathJax_Main&#39;,serif">i</span></em><span style="font-size: 13px;font-family:&#39;STIXMathJax_Main&#39;,serif">)</span></span><span style="vertical-align:-.201em">)</span><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">)</span></p><p style="margin-top:auto;margin-bottom:auto"><span style="font-size:16px;font-family:宋体"></span></p><pre class="brush:python;toolbar:false">#&nbsp;GRADED&nbsp;FUNCTION:&nbsp;compute_cost
&nbsp;
def&nbsp;compute_cost(AL,&nbsp;Y):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;Implement&nbsp;the&nbsp;cost&nbsp;function&nbsp;defined&nbsp;by&nbsp;equation&nbsp;(7).
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Arguments:
&nbsp;&nbsp;&nbsp;&nbsp;AL&nbsp;--&nbsp;probability&nbsp;vector&nbsp;corresponding&nbsp;to&nbsp;your&nbsp;label&nbsp;predictions,
&nbsp;&nbsp;&nbsp;&nbsp;shape&nbsp;(1,&nbsp;number&nbsp;of&nbsp;examples)
&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;--&nbsp;true&nbsp;&quot;label&quot;&nbsp;vector&nbsp;(for&nbsp;example:&nbsp;containing&nbsp;0&nbsp;if&nbsp;non-cat,&nbsp;1&nbsp;if&nbsp;cat),
&nbsp;&nbsp;&nbsp;&nbsp;shape&nbsp;(1,&nbsp;number&nbsp;of&nbsp;examples)
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Returns:
&nbsp;&nbsp;&nbsp;&nbsp;cost&nbsp;--&nbsp;cross-entropy&nbsp;cost
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;Y.shape[1]
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Compute&nbsp;loss&nbsp;from&nbsp;aL&nbsp;and&nbsp;y.
&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;1&nbsp;lines&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;cost&nbsp;=&nbsp;-1&nbsp;/&nbsp;m&nbsp;*&nbsp;np.sum(Y&nbsp;*&nbsp;np.log(AL)&nbsp;+&nbsp;(1-Y)&nbsp;*&nbsp;np.log(1-AL),axis=1,keepdims=True)
&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;cost&nbsp;=&nbsp;np.squeeze(cost)&nbsp;&nbsp;&nbsp;
&nbsp;#&nbsp;To&nbsp;make&nbsp;sure&nbsp;your&nbsp;cost&#39;s&nbsp;shape&nbsp;is&nbsp;what&nbsp;we&nbsp;expect&nbsp;(e.g.&nbsp;this&nbsp;turns&nbsp;[[17]]&nbsp;into&nbsp;17).
&nbsp;&nbsp;&nbsp;&nbsp;assert(cost.shape&nbsp;==&nbsp;())
&nbsp;&nbsp;&nbsp;&nbsp;
return&nbsp;cost</pre><p style="margin-top:auto;margin-bottom:auto;text-indent:32px"><span style="font-size:16px;font-family:宋体"></span><br/></p><h2>6 - 反向传播模块</h2><p>Just like with forward propagation, you will implement helper functions for backpropagation. Remember that back propagation is used to calculate the gradient of the loss function with respect to the parameters.</p><p><strong><span style="font-family:宋体">Reminder</span></strong>:</p><p style="margin-top: auto; margin-bottom: auto; text-align: center;"><img src="/wp-content/uploads/image/20180202/1517585078165939.jpg" title="1517585078165939.jpg" alt="1517585078165939.jpg" width="450" height="164"/></p><p style="text-align:center"><strong><span style="font-size:16px;font-family:宋体">Figure 3</span></strong><span style="font-size: 16px;font-family:宋体"> : Forward and Backward propagation for <em>LINEAR-&gt;RELU-&gt;LINEAR-&gt;SIGMOID</em> <br/> <em>The purple blocks represent the forward propagation, and the red blocks represent the backward propagation.</em> </span></p><p style="margin-top:auto;margin-bottom: auto;text-align:left"><span style="font-size:16px;font-family:宋体">Now, similar to forward propagation, you are going to build the backward propagation in three steps:</span></p><ul class=" list-paddingleft-2"><li><p><span style="font-size:16px;font-family:宋体">LINEAR backward</span></p></li><li><p><span style="font-size:16px;font-family:宋体">LINEAR -&gt; ACTIVATION backward where ACTIVATION computes the derivative of either the ReLU or sigmoid activation</span></p></li><li><p><span style="font-size:16px;font-family:宋体">[LINEAR -&gt;RELU] </span><span style="font-size:19px;font-family:&#39;STIXMathJax_Main&#39;,serif">×</span><span style="font-size:16px;font-family:宋体"> (L-1) -&gt; LINEAR -&gt; SIGMOID backward(whole model)</span></p></li></ul><h3>6.1 – 线性反馈</h3><p style="margin-top: auto; margin-bottom: auto;"><img src="/wp-content/uploads/image/20180202/1517585169770450.jpg" title="1517585169770450.jpg" alt="1517585169770450.jpg" width="670" height="75"/></p><p style="margin-top: auto; margin-bottom: auto;"><img src="/wp-content/uploads/image/20180202/1517585187107498.jpg" title="1517585187107498.jpg" alt="1517585187107498.jpg" width="670" height="104"/></p><p><strong><span style="font-family:等线">Exercise</span></strong>: Use the 3 formulas above to implement linear_backward().</p><pre class="brush:python;toolbar:false">#&nbsp;GRADED&nbsp;FUNCTION:&nbsp;linear_backward
&nbsp;
def&nbsp;linear_backward(dZ,&nbsp;cache):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;Implement&nbsp;the&nbsp;linear&nbsp;portion&nbsp;of&nbsp;backward&nbsp;propagation&nbsp;for&nbsp;a&nbsp;single&nbsp;layer&nbsp;(layer&nbsp;l)
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Arguments:
&nbsp;&nbsp;&nbsp;&nbsp;dZ&nbsp;--&nbsp;Gradient&nbsp;of&nbsp;the&nbsp;cost&nbsp;with&nbsp;respect&nbsp;to&nbsp;the&nbsp;linear&nbsp;output&nbsp;(of&nbsp;current&nbsp;layer&nbsp;l)
&nbsp;&nbsp;&nbsp;&nbsp;cache&nbsp;--&nbsp;tuple&nbsp;of&nbsp;values&nbsp;(A_prev,&nbsp;W,&nbsp;b)&nbsp;coming&nbsp;from&nbsp;the&nbsp;forward&nbsp;propagation&nbsp;in&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;layer
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Returns:
&nbsp;&nbsp;&nbsp;&nbsp;dA_prev--Gradient&nbsp;of&nbsp;the&nbsp;cost&nbsp;with&nbsp;respect&nbsp;to&nbsp;the&nbsp;activation(of&nbsp;the&nbsp;previous&nbsp;layerl-1),
&nbsp;&nbsp;&nbsp;&nbsp;same&nbsp;shape&nbsp;as&nbsp;A_prev
&nbsp;&nbsp;&nbsp;&nbsp;dW&nbsp;--&nbsp;Gradient&nbsp;of&nbsp;the&nbsp;cost&nbsp;with&nbsp;respect&nbsp;to&nbsp;W&nbsp;(current&nbsp;layer&nbsp;l),&nbsp;same&nbsp;shape&nbsp;as&nbsp;W
&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;--&nbsp;Gradient&nbsp;of&nbsp;the&nbsp;cost&nbsp;with&nbsp;respect&nbsp;to&nbsp;b&nbsp;(current&nbsp;layer&nbsp;l),&nbsp;same&nbsp;shape&nbsp;as&nbsp;b
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;A_prev,&nbsp;W,&nbsp;b&nbsp;=&nbsp;cache
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;A_prev.shape[1]
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;3&nbsp;lines&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;dW&nbsp;=&nbsp;1&nbsp;/&nbsp;m&nbsp;*&nbsp;np.dot(dZ&nbsp;,A_prev.T)
&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;=&nbsp;1&nbsp;/&nbsp;m&nbsp;*&nbsp;np.sum(dZ,axis&nbsp;=&nbsp;1&nbsp;,keepdims=True)
&nbsp;&nbsp;&nbsp;&nbsp;dA_prev&nbsp;=&nbsp;np.dot(W.T,dZ)
&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(dA_prev.shape&nbsp;==&nbsp;A_prev.shape)
&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(dW.shape&nbsp;==&nbsp;W.shape)
&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(db.shape&nbsp;==&nbsp;b.shape)
&nbsp;&nbsp;&nbsp;
return&nbsp;dA_prev,&nbsp;dW,&nbsp;db</pre><h3>6.2 – 线性激活函数反馈</h3><p>Next, you will create a function that merges the two helper functions: <code><strong>linear_backward</strong></code> and the backward step for the activation <code><strong>linear_activation_backward</strong></code>.</p><p>To help you implement <code>linear_activation_backward</code>, we provided two backward functions:</p><ul class=" list-paddingleft-2"><li><p><code><strong><span style="font-size:16px">sigmoid_backward</span></strong></code>: Implements the backward propagation for SIGMOID unit. You can &nbsp; &nbsp; &nbsp;call it as follows:</p></li></ul><pre style="margin-left:48px" class="brush:python;toolbar:false;">dZ&nbsp;=&nbsp;sigmoid_backward(dA,&nbsp;activation_cache)</pre><p><br/></p><ul class=" list-paddingleft-2"><li><p><strong><span style="font-size:16px;font-family:宋体">relu_backward</span></strong><span style="font-size:16px;font-family:宋体">: Implements the backward propagation for RELU &nbsp; &nbsp; &nbsp;unit. You can call it as follows:</span></p></li></ul><pre class="brush:python;toolbar:false">dZ&nbsp;=&nbsp;relu_backward(dA,&nbsp;activation_cache)</pre><p style="text-align:left"><span style="font-size:16px;font-family:宋体"></span><img src="/wp-content/uploads/image/20180202/1517585290422421.jpg" title="1517585290422421.jpg" alt="1517585290422421.jpg" width="640" height="67"/></p><pre class="brush:python;toolbar:false">#&nbsp;GRADED&nbsp;FUNCTION:&nbsp;linear_activation_backward
&nbsp;
def&nbsp;linear_activation_backward(dA,&nbsp;cache,&nbsp;activation):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;Implement&nbsp;the&nbsp;backward&nbsp;propagation&nbsp;for&nbsp;the&nbsp;LINEAR-&gt;ACTIVATION&nbsp;layer.
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Arguments:
&nbsp;&nbsp;&nbsp;&nbsp;dA&nbsp;--&nbsp;post-activation&nbsp;gradient&nbsp;for&nbsp;current&nbsp;layer&nbsp;l
&nbsp;&nbsp;&nbsp;&nbsp;cache&nbsp;--&nbsp;tuple&nbsp;of&nbsp;values&nbsp;(linear_cache,&nbsp;activation_cache)&nbsp;we&nbsp;store&nbsp;for&nbsp;computing
&nbsp;&nbsp;&nbsp;&nbsp;backward&nbsp;propagation&nbsp;efficiently
&nbsp;&nbsp;&nbsp;&nbsp;activation&nbsp;--&nbsp;the&nbsp;activation&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;this&nbsp;layer,&nbsp;stored&nbsp;as&nbsp;a&nbsp;text&nbsp;string:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&quot;sigmoid&quot;&nbsp;or&nbsp;&quot;relu&quot;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Returns:
&nbsp;&nbsp;&nbsp;&nbsp;dA_prev&nbsp;--&nbsp;Gradient&nbsp;of&nbsp;the&nbsp;cost&nbsp;with&nbsp;respect&nbsp;to&nbsp;the&nbsp;activation&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(of&nbsp;the&nbsp;previous&nbsp;layerl-1),&nbsp;same&nbsp;shape&nbsp;as&nbsp;A_prev
&nbsp;&nbsp;&nbsp;&nbsp;dW&nbsp;--&nbsp;Gradient&nbsp;of&nbsp;the&nbsp;cost&nbsp;with&nbsp;respect&nbsp;to&nbsp;W&nbsp;(current&nbsp;layer&nbsp;l),&nbsp;same&nbsp;shape&nbsp;as&nbsp;W
&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;--&nbsp;Gradient&nbsp;of&nbsp;the&nbsp;cost&nbsp;with&nbsp;respect&nbsp;to&nbsp;b&nbsp;(current&nbsp;layer&nbsp;l),&nbsp;same&nbsp;shape&nbsp;as&nbsp;b
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;linear_cache,&nbsp;activation_cache&nbsp;=&nbsp;cache
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;activation&nbsp;==&nbsp;&quot;relu&quot;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;2&nbsp;lines&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZ&nbsp;=&nbsp;relu_backward(dA,&nbsp;activation_cache)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dA_prev,&nbsp;dW,&nbsp;db&nbsp;=&nbsp;linear_backward(dZ,&nbsp;linear_cache)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;activation&nbsp;==&nbsp;&quot;sigmoid&quot;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;2&nbsp;lines&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZ&nbsp;=&nbsp;sigmoid_backward(dA,&nbsp;activation_cache)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dA_prev,&nbsp;dW,&nbsp;db&nbsp;=&nbsp;linear_backward(dZ,&nbsp;linear_cache)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
&nbsp;&nbsp;&nbsp;
return&nbsp;dA_prev,&nbsp;dW,&nbsp;db</pre><h3>6.3 – L层模型的反馈</h3><p>Now you will implement the backward function for the whole network. Recall that when you implemented the <code>L_model_forward</code> function, at each iteration, you stored a cache which contains (X,W,b, and z). In the back propagation module, you will use those variables to compute the gradients. Therefore, in the <code>L_model_backward</code> function, you will iterate through all the hidden layers backward, starting from layer <span style="display:inline-block"><em><span style="font-size:19px;font-family: &#39;STIXMathJax_Main&#39;,serif"><span style="display:inline-block"><span style="clip:rect(1.549em, 1000.54em, 2.56em, -1000em)">L</span></span></span></em></span>. On each step, you will use the cached values for layer <span style="color:inherit"><span style="display:inline-block"><span style="display:inline-block"><span style="clip:rect(1.519em, 1000.3em, 2.571em, -1000em)">l</span> to backpropagate through layerl</span></span>. Figure 5 below shows the backward pass.</span></p><p style="margin-top: auto; margin-bottom: auto; text-align: center;"><img src="/wp-content/uploads/image/20180202/1517585447137419.jpg" title="1517585447137419.jpg" alt="1517585447137419.jpg" width="670" height="368"/></p><p style="margin-top: auto; margin-bottom: auto;"><img src="/wp-content/uploads/image/20180202/1517585486746510.jpg" title="1517585486746510.jpg" alt="1517585486746510.jpg" width="650" height="170"/></p><h3>6.4 – 更新参数</h3><p>在本节，你将利用梯度下降算法更新模型的参数：</p><p style="margin-top: auto; margin-bottom: auto;"><img src="/wp-content/uploads/image/20180202/1517585520126996.jpg" title="1517585520126996.jpg" alt="1517585520126996.jpg" width="650" height="111"/></p><pre class="brush:python;toolbar:false">#&nbsp;GRADED&nbsp;FUNCTION:&nbsp;update_parameters
def&nbsp;update_parameters(parameters,&nbsp;grads,&nbsp;learning_rate):
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;Update&nbsp;parameters&nbsp;using&nbsp;gradient&nbsp;descent
&nbsp;&nbsp;&nbsp;&nbsp;Arguments:
&nbsp;&nbsp;&nbsp;&nbsp;parameters&nbsp;--&nbsp;python&nbsp;dictionary&nbsp;containing&nbsp;your&nbsp;parameters
&nbsp;&nbsp;&nbsp;&nbsp;grads&nbsp;--&nbsp;python&nbsp;dictionary&nbsp;containing&nbsp;your&nbsp;gradients,&nbsp;output&nbsp;of&nbsp;L_model_backward
&nbsp;&nbsp;&nbsp;&nbsp;Returns:
&nbsp;&nbsp;&nbsp;&nbsp;parameters&nbsp;--&nbsp;python&nbsp;dictionary&nbsp;containing&nbsp;your&nbsp;updated&nbsp;parameters
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters[&quot;W&quot;&nbsp;+&nbsp;str(l)]&nbsp;=&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters[&quot;b&quot;&nbsp;+&nbsp;str(l)]&nbsp;=&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;len(parameters)&nbsp;//&nbsp;2&nbsp;#&nbsp;number&nbsp;of&nbsp;layers&nbsp;in&nbsp;the&nbsp;neural&nbsp;network
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Update&nbsp;rule&nbsp;for&nbsp;each&nbsp;parameter.&nbsp;Use&nbsp;a&nbsp;for&nbsp;loop.
&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;START&nbsp;CODE&nbsp;HERE&nbsp;###&nbsp;(≈&nbsp;3&nbsp;lines&nbsp;of&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;l&nbsp;in&nbsp;range(L):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters[&quot;W&quot;+str(l+1)]=parameters[&quot;W&quot;+str(l+1)]-learning_rate*grads[&quot;dW&quot;+str(l+1)]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters[&quot;b&quot;+str(l+1)]=parameters[&quot;b&quot;+str(l+1)]-learning_rate*grads[&quot;db&quot;+str(l+1)]
&nbsp;&nbsp;&nbsp;&nbsp;###&nbsp;END&nbsp;CODE&nbsp;HERE&nbsp;###
return&nbsp;parameters</pre><h2>7 – 结论</h2><p style="margin-top:auto;margin-bottom: auto;text-align:left">祝贺你利用所有必须的函数完成了一个深度神经网络！</p><p style="margin-top:auto;margin-bottom: auto;text-align:left">我们指导这是一个很长但是继续往前会变得更好的大作业。作业的下一部分将会更简单。</p><p style="margin-top:auto;margin-bottom: auto;text-align:left">在接下来的部分，你将需要把所有的这些函数组合来创建两个模型：</p><ul class=" list-paddingleft-2"><li><p>两层神经网络</p></li><li><p>L层神经网络</p></li></ul><p style="margin-top:auto;margin-bottom: auto;text-align:left">你将能够利用这些模型来对猫/非猫图像进行分类！</p><p style="margin-top: auto; margin-bottom: auto;"><br/></p>
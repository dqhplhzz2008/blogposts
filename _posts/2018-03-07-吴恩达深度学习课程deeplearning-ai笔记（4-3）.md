---
ID: 3658
post_title: >
  吴恩达深度学习课程DeepLearning.ai笔记（4-3）
post_name: '%e5%90%b4%e6%81%a9%e8%be%be%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e8%af%be%e7%a8%8bdeeplearning-ai%e7%ac%94%e8%ae%b0%ef%bc%884-3%ef%bc%89'
author: 小奥
post_date: 2018-03-07 20:08:02
layout: post
link: >
  http://www.yushuai.me/2018/03/07/3658.html
published: true
tags:
  - 人工智能
  - 神经网络
categories:
  - Deep Learning
---
<p style="margin: 8px 0 16px;line-height: 32px;background: white"><strong><span style="font-size:24px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">卷积神经网络 —&nbsp;目标检测</span></strong></p><p style="line-height: 30px;background: white"><a></a><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">1. </span></strong><strong><span style="font-size: 22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">目标定位&amp;特征点检测-目标检测</span></strong></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">图片检测的三个问题：</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">）分类问题：区分图片是汽车亦或是其它；</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">）目标定位：判断是否是汽车并确定其位置；</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">3</span><span style=";font-family:宋体;color:#4F4F4F">）目标检测：源图中有多个不同的物体，分析确定该物体是什么并确定位置。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">）目标分类与定位</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">如图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">所示。</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Softmax</span><span style=";font-family:宋体;color:#4F4F4F">后面可以有多个输出，其输出结果是各项目标的可能性。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">定位最关键的就是输出图中红圈的中心点的坐标（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">bx,by</span><span style=";font-family:宋体;color:#4F4F4F">），然后就是它的宽</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">bw</span><span style=";font-family:宋体;color:#4F4F4F">和高</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">bh</span><span style=";font-family:宋体;color:#4F4F4F">。通常以图片的左上角坐标为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">(0,0)</span><span style=";font-family:宋体;color:#4F4F4F">，右下角为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">(1,1)</span><span style=";font-family:宋体;color:#4F4F4F">。</span></p><p style="text-align:center"><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427639519641.jpg" title="1520427639519641.jpg" alt="1520427639519641.jpg" width="579" height="274"/></span></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">）定义目标标签</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">y</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">我们的代价函数可以如下式所示：</span></p><p style="text-align:center"><img src="/wp-content/uploads/image/20180308/1520476789127284.jpg" title="1520476789127284.jpg" alt="1520476789127284.jpg" width="360" height="58"/></p><p style=";background:white"><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">&nbsp;&nbsp;&nbsp; </span><span style=";font-family:宋体;color:#4F4F4F">我们可以知道，当处于第一行状态时，我们需要关注神经网络对所有输出值的准确度；而当第二行状态时，只需要关注对于背景的准确度。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">经过神经网络后输出一个</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">n</span><span style=";font-family:宋体;color:#4F4F4F">×</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">的矩阵。这里我们假设检测车、行人、摩托车。那么这个矩阵可以如图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">所示：</span></p><p style="text-align:center"><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427664130997.jpg" title="1520427664130997.jpg" alt="1520427664130997.jpg" width="200" height="208"/></span></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">每一个参数的含义都已经在图中表示出来了。注意，若</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">P<sub>C</sub>=0</span><span style=";font-family:宋体;color:#4F4F4F">，则后面的参数无论取何值都无意义。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">3</span><span style=";font-family:宋体;color:#4F4F4F">）特征点检测</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">特征点检测，顾名思义，就是根据图片上的特征点的坐标实现对目特征的识别和定位。就像图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">3</span><span style=";font-family:宋体;color:#4F4F4F">中女性的眼角，运动员的动作姿势等，都可以成为被标记的特征点。</span></p><p style="text-align:center"><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427683417153.jpg" title="1520427683417153.jpg" alt="1520427683417153.jpg" width="579" height="325"/></span></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">3</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">4</span><span style=";font-family:宋体;color:#4F4F4F">）目标检测</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">实现目标检测，就是采用定义一个小窗口，然后就像推拉门一样滑动来进行检测。</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:#4F4F4F">训练模型：</span></strong></p><p style="background: white; text-align: center;"><strong><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427703308952.jpg" title="1520427703308952.jpg" alt="1520427703308952.jpg" width="289" height="241"/></span></strong></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">4</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">将训练集的图片切割成一个一个小图片，然后对其进行标记：若有汽车，标记为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">；若无汽车，标记为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">0</span><span style=";font-family:宋体;color:#4F4F4F">。</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:#4F4F4F">滑动窗口检测：</span></strong></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">首先选定一个特定大小的框，被称为窗口，将窗口放到图片上进行预测。如图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">5</span><span style=";font-family:宋体;color:#4F4F4F">所示，图中三张图片分别应用了</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">3</span><span style=";font-family:宋体;color:#4F4F4F">种不同尺寸的窗口。不同尺寸的窗口有什么优缺点呢？选用尺寸较大的窗口，优点是减少了数据量，但是缺点是检测的准确率下降；对于尺寸较小的窗口来说，优点是检测的准确率得到提升，但是数据量却变得十分庞大。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">然后以固定的步幅长度来滑动该窗口，遍历图像的各个区域，对窗内的各个小图输入模型进行预测。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">这之后，需要继续选取一个更大的窗口，然后再重复遍历图像每个区域的动作，以对是否有车进行预测。</span></p><p style="text-align:center"><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427735918735.jpg" title="1520427735918735.jpg" alt="1520427735918735.jpg" width="579" height="306"/></span></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style="color: #4F4F4F;"><span style="font-family:Arial, sans-serif">5</span></span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:#4F4F4F">卷积层代替全连接层：</span></strong></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">如图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">6</span><span style=";font-family:宋体;color:#4F4F4F">所示，对于图中上侧的部分来说，它是使用了两个</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">400</span><span style=";font-family:宋体;color:#4F4F4F">个节点的全连接层，然后通过</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Softmax</span><span style=";font-family:宋体;color:#4F4F4F">输出了分类的概率等等信息。但是实际上，利用</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">×</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">的卷积核，如该图下半部分所示，也可以实现类似的结果。这一点的原理在前面已经讲过，在此不再累述。</span></p><p style="background: white; text-align: center; text-indent: 0em;"><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427760258862.jpg" title="1520427760258862.jpg" alt="1520427760258862.jpg" width="579" height="278"/></span></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">6</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:#4F4F4F">滑动窗口的卷积实现：</span></strong></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">如图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">7</span><span style=";font-family:宋体;color:#4F4F4F">所示：</span></p><p style="background: white; text-align: center; text-indent: 0em;"><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427782119562.jpg" title="1520427782119562.jpg" alt="1520427782119562.jpg" width="579" height="296"/></span></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">7</span></p><p style=";background:white"><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">&nbsp;&nbsp;&nbsp; </span><span style=";font-family:宋体;color:#4F4F4F">我们可以使用上面已经训练好的模型，应该注意到，虽然图片中使用的是平面图，但是实际上它是一个三维的。我们输入一个</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">16×16×3</span><span style=";font-family:宋体;color:#4F4F4F">的图片，在图中蓝色代表滑动窗口。在这里，我们设置步长为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">，然后分别于卷积核进行卷积运算，最后得到了</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">4</span><span style=";font-family:宋体;color:#4F4F4F">个</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">10×10×16</span><span style=";font-family:宋体;color:#4F4F4F">的特征图。由于在滑动的过程中必然存在大量的重叠，因此在下一层的特征图中也是存在大量重叠。在第二部分中，实际上我们是利用增加了一个</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">padding</span><span style=";font-family:宋体;color:#4F4F4F">进行处理，具体的过程和第一部分类似。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">那么由此可知，滑动窗口在整幅图片上进行滑动卷积的操作过程，就等同于在该图片上直接进行卷积运算的过程。所以卷积层实现滑动窗口的这个过程，我们不需要把输入图片分割成四个子集分别执行前向传播，而是把他们作为一张图片输入到卷积神经网络中进行计算，其中的重叠部分（公共区域）可以共享大量的计算。</span></p><p style="line-height: 30px;background: white"><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">2. Bounding Box</span></strong><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">预测（YOLO算法）</span></strong></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">前面的讨论一直在理想情况下，实际上我们不能输出最精准的边界框（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Bounding Box</span><span style=";font-family:宋体;color:#4F4F4F">）。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">这个时候我们可以使用</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">YOLO</span><span style=";font-family:宋体;color:#4F4F4F">算法。下面开始介绍</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">YOLO</span><span style=";font-family:宋体;color:#4F4F4F">算法。</span></p><p style="text-align:center"><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427805468540.jpg" title="1520427805468540.jpg" alt="1520427805468540.jpg" width="579" height="327"/></span></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">8</span></p><p class="MsoListParagraph" style="margin-left:56px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">在整个图片上加较为精细的网格，将图片分为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">n×n</span><span style=";font-family:宋体;color:#4F4F4F">的小方格；</span></p><p class="MsoListParagraph" style="margin-left:56px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">然后利用前述的图像分类和定位，将其分别应用在这些小方格之中；</span></p><p class="MsoListParagraph" style="margin-left:56px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">对每一个小方格定义训练标签</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">yi</span><span style=";font-family:宋体;color:#4F4F4F">（标签内容如前图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">所示）；</span></p><p class="MsoListParagraph" style="margin-left:56px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">将这些小方格的标签合并在一起，最终输出</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Y</span><span style=";font-family:宋体;color:#4F4F4F">，它的大小为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">n×n×8</span><span style=";font-family:宋体;color:#4F4F4F">。</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">通过观察不同位置的输出值，我们就能知道这些位置中是否存在目标物体，然后也能由存在物体的输出向量得到目标物体的更加精准的边界框。</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:red">注意：</span></strong></p><p style=";background:white"><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">&nbsp;&nbsp;&nbsp; </span><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">）将对象分配到一个格子的过程是：观察对象的中点，将该对象分配到其中点所在的格子中，（即使对象横跨多个格子，也只分配到中点所在的格子中，其他格子记为无该对象，即标记为“</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">0”</span><span style=";font-family:宋体;color:#4F4F4F">）；</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">）</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">YOLO</span><span style=";font-family:宋体;color:#4F4F4F">显式地输出边界框，使得其可以具有任意宽高比，并且能输出更精确的坐标，不受滑动窗口算法滑动步幅大小的限制；</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">3</span><span style=";font-family:宋体;color:#4F4F4F">）</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">YOLO</span><span style=";font-family:宋体;color:#4F4F4F">是一次卷积实现，并不是在</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">n×n</span><span style=";font-family:宋体;color:#4F4F4F">网格上进行</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">n<sup>2</sup></span><span style=";font-family:宋体;color:#4F4F4F">次运算，而是单次卷积实现，算法实现效率高，运行速度快，可以实现实时识别。</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:red">我们做以下约定：</span></strong></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">对于每个网格，以左上角为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">(0,0)</span><span style=";font-family:宋体;color:#4F4F4F">，以右下角为</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">(1,1)</span><span style=";font-family:宋体;color:#4F4F4F">；</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">中点</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">bx</span><span style=";font-family:宋体;color:#4F4F4F">、</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">by</span><span style=";font-family:宋体;color:#4F4F4F">表示坐标值，在</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">0~1</span><span style=";font-family:宋体;color:#4F4F4F">之间；</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">宽高</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">bh</span><span style=";font-family:宋体;color:#4F4F4F">、</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">bw</span><span style=";font-family:宋体;color:#4F4F4F">表示比例值，存在</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">&gt;1</span><span style=";font-family:宋体;color:#4F4F4F">的情况。</span></p><p style="line-height: 30px;background: white"><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">3. </span></strong><strong><span style="font-size: 22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">交并比（LOU）与非最大值抑制（NMS）</span></strong></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">）交并比</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">如图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">9</span><span style=";font-family:宋体;color:#4F4F4F">所示，所谓交并比指的是图中橘黄色部分比上绿色部分。这个参数是用来衡量目标检测算法是否运作良好。一般情况下，当</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">LOU</span><span style=";font-family:宋体;color:#4F4F4F">≥</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">0.5</span><span style=";font-family:宋体;color:#4F4F4F">的时候，说明检测正确。</span></p><p style="background: white; text-indent: 0em; text-align: center;"><span style="color:#4f4f4f;font-family:宋体"><img src="/wp-content/uploads/image/20180307/1520427852789113.jpg" title="1520427852789113.jpg" alt="1520427852789113.jpg" width="235" height="241"/></span></p><p style="background: white; text-indent: 0em; text-align: center;"><span style="color:#4f4f4f;font-family:宋体">图9</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">）非最大值抑制</span></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">该方法解决了相同的物体被重复检测的问题。</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:#4F4F4F">算法思想：</span></strong></p><p class="MsoListParagraph" style="margin-left:28px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">在对</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">n×n</span><span style=";font-family:宋体;color:#4F4F4F">个网格进行目标检测算法后，每个网格输出的</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Pc</span><span style=";font-family:宋体;color:#4F4F4F">为一个</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">0~1</span><span style=";font-family:宋体;color:#4F4F4F">的值，表示有车的概率大小。其中会有多个网格内存在高概率；</span></p><p class="MsoListParagraph" style="margin-left:28px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">得到对同一个对象的多次检测，也就是在一个对象上有多个具有重叠的不同的边界框；</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">非最大值抑制对多种检测结果进行清理：选取最大</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Pc</span><span style=";font-family:宋体;color:#4F4F4F">的边界框，对所有其他与该边界框具有高交并比或高重叠的边界框进行抑制；</span></p><p class="MsoListParagraph" style="margin-left:28px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">逐一审视剩下的边界框，寻找最高的</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Pc</span><span style=";font-family:宋体;color:#4F4F4F">值边界框，重复上面的步骤。</span></p><p class="MsoListParagraph" style="margin-left:28px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">非最大值抑制，也就是说抑制那些不是最大值，却比较接近最大值的边界框。</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:#4F4F4F">算法步骤：</span></strong></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">1</span><span style=";font-family:宋体;color:#4F4F4F">）对于图片每个网格预测输出矩阵：</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">yi=[Pc bx by bh bw]</span><span style=";font-family:宋体;color:#4F4F4F">，其中</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Pc</span><span style=";font-family:宋体;color:#4F4F4F">表示有对象的概率；</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">）抛弃</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Pc</span><span style=";font-family:&#39;Cambria Math&#39;,serif;color:#4F4F4F">⩽</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">0.6</span><span style=";font-family:宋体;color:#4F4F4F">的边界框；</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">3</span><span style=";font-family:宋体;color:#4F4F4F">）对剩余的边界框（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">while</span><span style=";font-family:宋体;color:#4F4F4F">）：选取最大</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Pc</span><span style=";font-family:宋体;color:#4F4F4F">值的边界框，作为预测输出边界框；抛弃和选取的边界框</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">IoU</span><span style=";font-family:&#39;Cambria Math&#39;,serif;color:#4F4F4F">⩾</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">0.5IoU</span><span style=";font-family:&#39;Cambria Math&#39;,serif;color:#4F4F4F">⩾</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">0.5</span><span style=";font-family:宋体;color:#4F4F4F">的剩余的边界框。</span></p><p style="text-align:center"><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427878111221.jpg" title="1520427878111221.jpg" alt="1520427878111221.jpg" width="579" height="294"/></span></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">10</span></p><p style="line-height: 30px;background: white"><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">4. Anchor box</span></strong></p><p style="text-indent:28px;background:white"><span style=";font-family:宋体;color:#4F4F4F">到目前为止，我们已经完成了我们想要完成的任务。但是这存在一个问题，即目前我们只能检测一个对象，这很显然是不够的。那怎样才能检测多个对象呢？这里我们可以使用</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Anchor box</span><span style=";font-family:宋体;color:#4F4F4F">。</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:#4F4F4F">重叠目标：</span></strong></p><p style="text-align:center"><strong><span style=";font-family:宋体;color:#4F4F4F"><img src="/wp-content/uploads/image/20180307/1520427895320598.jpg" title="1520427895320598.jpg" alt="1520427895320598.jpg" width="579" height="285"/></span></strong></p><p style="text-align:center;background:white"><span style=";font-family:宋体;color:#4F4F4F">图</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">11</span></p><p style=";background:white"><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">&nbsp;&nbsp;&nbsp; </span><span style=";font-family:宋体;color:#4F4F4F">对于重叠的目标，这些目标的中点有可能会落在同一个网格中，对于我们之前定义的输出只能得到一个目标的输出。</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">而</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Anchor box </span><span style=";font-family:宋体;color:#4F4F4F">则是预先定义多个不同形状的</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Anchor box</span><span style=";font-family:宋体;color:#4F4F4F">，我们需要把预测目标对应地和各个</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Anchor box </span><span style=";font-family:宋体;color:#4F4F4F">关联起来，所以我们重新定义目标向量：</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">yi=[Pc bx by bh bw c1 c2 c3 Pc bx by bh bw c1 c2 c3</span><span style=";font-family:宋体;color:#4F4F4F">。。。</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">]</span><span style=";font-family:宋体;color:#4F4F4F">。用这样的多目标向量分别对应不同的</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Anchor box</span><span style=";font-family:宋体;color:#4F4F4F">，从而检测出多个重叠的目标。</span></p><p style=";background:white"><strong><span style=";font-family:宋体;color:red">总结：</span></strong></p><p class="MsoListParagraph" style="margin-left:28px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">之前的算法：在训练图像中的每一个目标被分配一个包含目标重点的格子，输出大小。（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Each object in training image is assigned to grid cell that contains that object’s midpoint.</span><span style=";font-family:宋体;color:#4F4F4F">）</span></p><p class="MsoListParagraph" style="margin-left:28px;background:white"><span style=";font-family:Wingdings;color:#4F4F4F">l<span style="font-variant-numeric: normal;font-stretch: normal;font-size: 9px;line-height: normal;font-family: &#39;Times New Roman&#39;">&nbsp; </span></span><span style=";font-family:宋体;color:#4F4F4F">使用</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">2</span><span style=";font-family:宋体;color:#4F4F4F">个</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Anchor boxes</span><span style=";font-family:宋体;color:#4F4F4F">：</span> <span style=";font-family:宋体;color:#4F4F4F">每一个训练图像中的目标都被分配包含对象中点的网格单元格和具有最高</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">IoU</span><span style=";font-family:宋体;color:#4F4F4F">的网格单元格的锚点框。（</span><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">Each object in training image is assigned to grid cell that contains object’s midpoint and anchor box for the grid cell with highest IoU.</span><span style=";font-family:宋体;color:#4F4F4F">）</span></p><p style=";background:white"><span style=";font-family:宋体;color:#4F4F4F">更多内容参见：</span><strong><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F"> Redmon et al., 2015, You Only Look Once: Unified real-time object detection</span></strong></p><p style=";background:white"><span style=";font-family:&#39;Arial&#39;,sans-serif;color:#4F4F4F">&nbsp;</span></p><p><br/></p>
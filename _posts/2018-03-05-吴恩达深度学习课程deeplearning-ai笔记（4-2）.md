---
ID: 3650
post_title: >
  吴恩达深度学习课程DeepLearning.ai笔记（4-2）
post_name: '%e5%90%b4%e6%81%a9%e8%be%be%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e8%af%be%e7%a8%8bdeeplearning-ai%e7%ac%94%e8%ae%b0%ef%bc%884-2%ef%bc%89'
author: 小奥
post_date: 2018-03-05 20:40:31
layout: post
link: >
  http://www.yushuai.me/2018/03/05/3650.html
published: true
tags:
  - Python
  - 人工智能
  - 机器学习
  - 神经网络
categories:
  - Deep Learning
---
<p style="margin: 8px 0 16px;line-height: 32px;background: white"><strong><span style="font-size:24px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">卷积神经网络 —&nbsp;深度卷积模型</span></strong></p><p style="line-height: 30px;background: white"><a></a><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">1. </span></strong><strong><span style="font-size: 22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">经典的卷积网络</span></strong></p><p style="text-indent:28px">本节，吴恩达教授介绍了几种经典的神经网络模型，分别是LeNet、AlexNet、VGGNet，并且提到了后面要介绍的ResNet（残差网络）和Google的Inception。接下来对本节介绍的网络分别做一个简单的介绍。</p><p>（1）LeNet-5：</p><p style="text-indent:28px">如图1 所示。LeNet-5主要针对灰度设计，所以其输入尺寸比较小，大小为32×32×1（灰度图像没有三维的RGB）。</p><p style="text-indent: 28px; text-align: center;"><img src="/wp-content/uploads/image/20180305/1520257750879198.jpg" title="1520257750879198.jpg" alt="1520257750879198.jpg" width="580" height="277"/></p><p style="text-align:center">图1</p><p style="text-indent:28px">从图中可以看出，在LeNet的经典模式中：随着网络深度增加，图像的大小在缩小，但是通道却在增加；每个卷积层后面连接一个池化层。</p><p>（2）AlexNet：</p><p style="text-indent:28px">如图2所示，该网络用语对彩色的图片进行处理。注意，虽然源论文中不是采用227×227×3，但在实际测试中，该尺寸效果更好。</p><p style="text-indent: 28px; text-align: center;"><img src="/wp-content/uploads/image/20180305/1520257774775352.jpg" title="1520257774775352.jpg" alt="1520257774775352.jpg" width="580" height="247"/></p><p style="text-align:center">图2</p><p style="text-indent:28px">与前面的LeNet类似，但是该网络结构更复杂，参数也更多，相应的表现也更加好。该网络使用了RELU，使用了多个GPU。</p><p>（3）VGG-16：</p><p style="text-indent:28px">VGG卷积层和池化层具有相同的大小，都是3×3，步长stride=1，SAME的卷积核为2×2，步长为2的池化结构，其结构如图3所示：</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180305/1520257857205197.jpg" title="1520257857205197.jpg" alt="1520257857205197.jpg" width="580" height="306"/></p><p style="text-align:center">图3</p><p>（4）ResNet（残差网络）</p><p style="text-indent:28px">残差网络是由残差块构建的网络。那么什么是残差块呢？下面来做一个解释。</p><p style="text-indent:28px">下面是一个普通的的神经网络块传输<span style="font-size: 14px; text-indent: 28px;">（暂时无视a</span><sup style="text-indent: 28px; white-space: normal;">[l]</sup><span style="font-size: 14px; text-indent: 28px;">到a</span><sup style="text-indent: 28px; white-space: normal;">[l+2]</sup><span style="font-size: 14px; text-indent: 28px;">的这条线）</span>：</p><p style="text-indent: 28px; text-align: center;"><img src="https://dqhplhzz2008-1251830035.cos.ap-guangzhou.myqcloud.com/wp-content/uploads/image/20180305/1520257805882694.jpg" title="1520257805882694.jpg" alt="1520257805882694.jpg" width="412" height="213"/></p><p style="text-align:center">图4</p><p style="text-indent:28px">其前向传播过程分别是一个线性、RELU、线性、RELU的过程。而残差块则是增加了一个将a<sup>[l]</sup>直接连接到a<sup>[l+2]</sup>的过程，如图5所示，这个过程称为short cut或者skip connection。</p><p style="text-indent: 28px; text-align: center;"><img src="/wp-content/uploads/image/20180305/1520257872939773.jpg" title="1520257872939773.jpg" alt="1520257872939773.jpg" width="580" height="195"/></p><p style="text-align:center">图5</p><p style="text-indent:28px">完整的残差块结构如图3所示。务必注意，<strong><span style="color:red">这个连接在RELU activation function之前</span></strong>！</p><p style="text-indent:28px">多个残差块连接起来就构成了ResNet网络。（<strong><span style="color:red">注意，在论文中，普通的神经网络被称为Plain Network</span></strong>）</p><p style="text-indent:28px">在学习神经网络的时候就提到了，<strong><span style="color:#0070C0">ResNet</span><span style="color:#0070C0">对于中间的激活函数来说，有助于能够达到更深的网络，解决梯度消失和梯度爆炸的问题</span></strong>。</p><p style="text-indent:28px">为什么残差网络表现能很好呢？</p><p style="text-indent:28px">假设我们有一个Big NN，其输入为x，输出为a<sup>[l]</sup>，如果我们想增加网络深度的话，同时也给其增加一个残差块：</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180305/1520257890727981.jpg" title="1520257890727981.jpg" alt="1520257890727981.jpg" width="580" height="146"/></p><p style="text-align:center">图6</p><p style="text-indent:28px">假设网络中我们都是用RELU activation function，那么最后的输出a≥0，这里的a<sup>[l+2]</sup>我们可以知道为：</p><p style="text-align:center">a<sup>[l+2]</sup>=g(z<sup>[l+2]</sup>+ a<sup>[l]</sup>)=g(W<sup>[l+2]</sup> a<sup>[l+1]</sup>+ b<sup>[l+2]</sup>+ a<sup>[l]</sup>)</p><p style="text-indent:28px">如果使用L-2正则化或者权重衰减，就会压缩W和b的值，如果W<sup>[l+2]</sup>=0同时b<sup>[l+2]</sup>=0，那么</p><p style="text-align:center">a<sup>[l+2]</sup>=g(z<sup>[l+2]</sup>+ a<sup>[l]</sup>)=g(a<sup>[l]</sup>)=relu(a<sup>[l]</sup>)= a<sup>[l]</sup></p><p style="text-indent:28px">因此我们可以看到，对于残差块来说学习上面这个恒等的函数是很容易的。所以在增加了残差块后更深网络的性能也不差于plain network。同时，如果增加的网络结构能够学习到一些有用信息，那么就会提升网络的性能。</p><p style="line-height: 30px;background: white"><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">2. 1</span></strong><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">×1卷积</span></strong></p><p style="text-indent:28px">什么是1×1卷积呢？</p><p style="text-indent:28px">就是卷积核是一个1×1的元素。虽然说看起来这种卷积似乎没什么作用，但实际上作用非常大。</p><p style="text-indent:28px">在二维上，这种卷积相当于图片每个元素与这个卷积核数字相乘。但是在三维上，与1×1×nc的卷积核进行卷积，就相当于三维图像上的1×1×nc的切片，也就是nc个点乘卷积数值权重，通过RELU函数输出对应结果。而不同的卷积核则相当于不同的隐层神经元节点与切片上的点一一连接。所以本质上这个卷积核相当于对一个切片上nc个单元都应用了一个全连接的神经网络。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180305/1520257912117229.jpg" title="1520257912117229.jpg" alt="1520257912117229.jpg" width="580" height="298"/></p><p style="text-align: center;">图7</p><p style="text-indent:28px">最后得到了一个相同长宽但第三维度变成卷积核个数的图片。</p><p style="text-indent:28px">应用：维度压缩和增加非线性。</p><p style="line-height: 30px;background: white"><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">3. Inception Network</span></strong></p><p style="text-indent:28px">Inception Network 的作用就是使我们无需去考虑在构建深度卷积神经网络时，使用多大的卷积核以及是否添加池化层等问题。</p><p>Inception主要结构：</p><p style="text-align: center;"><img src="/wp-content/uploads/image/20180305/1520257931725545.jpg" title="1520257931725545.jpg" alt="1520257931725545.jpg" width="580" height="326"/></p><p style="text-align:center">图8</p><p>在上面的Inception结构中，应用了不同的卷积核，以及带padding的池化层。在保持输入图片大小不变的情况下，通过不同运算结果的叠加，增加了通道的数量。</p><p>计算成本的问题：</p><p>对于上面的5×大小卷积核计算成本：</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180305/1520257946113573.jpg" title="1520257946113573.jpg" alt="1520257946113573.jpg" width="580" height="351"/></p><p style="text-align:center">图9</p><p>1 filters：5×5×192；</p><p>32 个 filters；</p><p>总的计算成本：28×28×32×5×5×192=120M</p><p>对于1×1×1大小卷积核用作过渡的计算成本，也将下面的中间的层叫做“bottleneck layer”：</p><p>1×1×1卷积层计算成本：28×28×16×1×1×192=2.4M</p><p>5×5×5卷积层计算成本：28×28×32×5×5×16=10.0M</p><p>总的计算成本：2.4M+10.0M=12.4M</p><p style="text-align: center;"><img src="/wp-content/uploads/image/20180305/1520257973102235.jpg" title="1520257973102235.jpg" alt="1520257973102235.jpg" width="580" height="333"/></p><p><br/></p><p style="text-align:center">图10</p><p style="text-indent:28px">所以1×1×1卷积核作为bottleneck layer”的过渡层能够有效减小卷积神经网的计算成本。事实证明，只要合理地设置“bottleneck layer”，既可以显著减小上层的规模，同时又能降低计算成本，从而不会影响网络的性能。</p><p style="text-indent:28px">Inception的单个单元结构和总体结构如图11和图12所示。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180305/1520257986105667.jpg" title="1520257986105667.jpg" alt="1520257986105667.jpg" width="580" height="326"/></p><p style="text-align:center">图11</p><p style="text-align: center;"><img src="/wp-content/uploads/image/20180305/1520258011527791.jpg" title="1520258011527791.jpg" alt="1520258011527791.jpg" width="580" height="323"/></p><p style="text-align:center">图12</p><p style="line-height: 30px;background: white"><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">4. </span></strong><strong><span style="font-size: 22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">迁移学习</span></strong></p><p><strong><span style="color:#843C0C">此部分不再累述。</span></strong></p><p style="line-height: 30px;background: white"><strong><span style="font-size:22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">5. </span></strong><strong><span style="font-size: 22px;font-family:&#39;微软雅黑&#39;,sans-serif;color:#4F4F4F">数据扩充</span></strong></p><p>方法：镜像旋转、随机剪裁、色彩转换（PCA颜色增强）等。</p><p><span style="color: #A5A5A5;"><em>本笔记部分参考了http://blog.csdn.net/koala_tree/article/details/78531398，对原作者表示感谢。</em></span></p>
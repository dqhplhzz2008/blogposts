---
ID: 3783
post_title: >
  数据结构【浙江大学】（第8节）整理
post_name: '%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e3%80%90%e6%b5%99%e6%b1%9f%e5%a4%a7%e5%ad%a6%e3%80%91%ef%bc%88%e7%ac%ac8%e8%8a%82%ef%bc%89%e6%95%b4%e7%90%86'
author: 小奥
post_date: 2018-05-12 16:21:31
layout: post
link: >
  http://www.yushuai.me/2018/05/12/3783.html
published: true
tags:
  - 数据结构
categories:
  - Data Structure
---
<h1>第八讲：图（下）</h1><h2>8.1 最小生成树问题</h2><p><strong>8.1.1 最小生成树（Minimum Spanning Tree）</strong></p><p style="text-indent:28px">如图1所示。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180512/1526113146122922.jpg" title="1526113146122922.jpg" alt="1.jpg"/>&nbsp;</p><p style="text-align:center">图1</p><p style="text-indent:28px">它是一棵树：无回路；|V|个顶点一定有|V|-1条边；</p><p style="text-indent:28px">它是生成树：包含全部顶点；|V|-1条边都在图里。在图1中，第2/3/4个图都是图1的生成树，可以看出，<strong><span style="color:red">生成树中任加一条边都一定构成回路</span></strong>。</p><p style="text-indent:28px">最小：边的权重和<strong><span style="color:red">最小</span></strong>。</p><p style="text-indent:28px">显然可以得出，<strong><span style="color:#C00000">最小生成树存在&lt;-&gt;图连通</span></strong>。</p><p><strong>8.1.2 贪心算法</strong></p><p style="text-indent:28px">贪：每一步都要最好的。好：权重最小的边。</p><p style="text-indent:28px">需要约束：只能用图里有的边；只能正好用掉|V|-1条边；不能有回路。</p><p><strong>8.1.3 Prim算法（密集图）—让一棵小树长大</strong></p><p style="text-indent:28px">如图2所示，我们选择v1作为源节点，选择权重最小的（为1），到v4；然后我们看这个图，权重最小的为2有两个边，分别到v2和v3，我们先选择连到v2，再用v4连接到v3；为了不构成回路，我们需要选择权重为4的由v4到v7的边；再选择权重为1的v6，再选择权重为6的v5。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180512/1526113152617262.jpg" title="1526113152617262.jpg" alt="2.jpg"/>&nbsp;</p><p style="text-align:center">图2</p><p style="text-indent:28px">其伪码描述如下，其中dist[V]=E(s,v)或正无穷，parent[s]=-1：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Prim()
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MST={s};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V=未收录顶点中dist最小者;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(V不存在)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将V收录进MST,dist[V]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(V的每一个邻接点W)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(dist[W]!=0)/*即这个点未被收入*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(E[V,W]&lt;dist[W]){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist[W]=E[V,W];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent[W]=v;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(MST中收的顶点不到|V|个)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error(&quot;生成树不存在&quot;);
}</pre><p style="text-indent:28px">完整代码：</p><pre class="brush:cpp;toolbar:false">/*&nbsp;邻接矩阵存储&nbsp;-&nbsp;Prim最小生成树算法&nbsp;*/
&nbsp;
Vertex&nbsp;FindMinDist(&nbsp;MGraph&nbsp;Graph,&nbsp;WeightType&nbsp;dist[]&nbsp;)
{&nbsp;/*&nbsp;返回未被收录顶点中dist最小者&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;MinV,&nbsp;V;
&nbsp;&nbsp;&nbsp;&nbsp;WeightType&nbsp;MinDist&nbsp;=&nbsp;INFINITY;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(V=0;&nbsp;V&lt;Graph-&gt;Nv;&nbsp;V++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dist[V]!=0&nbsp;&amp;&amp;&nbsp;dist[V]&lt;MinDist)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;若V未被收录，且dist[V]更小&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinDist&nbsp;=&nbsp;dist[V];&nbsp;/*&nbsp;更新最小距离&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinV&nbsp;=&nbsp;V;&nbsp;/*&nbsp;更新对应顶点&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(MinDist&nbsp;&lt;&nbsp;INFINITY)&nbsp;/*&nbsp;若找到最小dist&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;MinV;&nbsp;/*&nbsp;返回对应的顶点下标&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;return&nbsp;ERROR;&nbsp;&nbsp;/*&nbsp;若这样的顶点不存在，返回-1作为标记&nbsp;*/
}
&nbsp;
int&nbsp;Prim(&nbsp;MGraph&nbsp;Graph,&nbsp;LGraph&nbsp;MST&nbsp;)
{&nbsp;/*&nbsp;将最小生成树保存为邻接表存储的图MST，返回最小权重和&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;WeightType&nbsp;dist[MaxVertexNum],&nbsp;TotalWeight;
&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;parent[MaxVertexNum],&nbsp;V,&nbsp;W;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;VCount;
&nbsp;&nbsp;&nbsp;&nbsp;Edge&nbsp;E;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;初始化。默认初始点下标是0&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(V=0;&nbsp;V&lt;Graph-&gt;Nv;&nbsp;V++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist[V]&nbsp;=&nbsp;Graph-&gt;G[0][V];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent[V]&nbsp;=&nbsp;0;&nbsp;/*&nbsp;暂且定义所有顶点的父结点都是初始点0&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;TotalWeight&nbsp;=&nbsp;0;&nbsp;/*&nbsp;初始化权重和&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;VCount&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;初始化收录的顶点数&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;创建包含所有顶点但没有边的图。注意用邻接表版本&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;MST&nbsp;=&nbsp;CreateGraph(Graph-&gt;Nv);
&nbsp;&nbsp;&nbsp;&nbsp;E&nbsp;=&nbsp;(Edge)malloc(&nbsp;sizeof(struct&nbsp;ENode)&nbsp;);&nbsp;/*&nbsp;建立空的边结点&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;将初始点0收录进MST&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dist[0]&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;VCount&nbsp;++;
&nbsp;&nbsp;&nbsp;&nbsp;parent[0]&nbsp;=&nbsp;-1;&nbsp;/*&nbsp;当前树根是0&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;=&nbsp;FindMinDist(&nbsp;Graph,&nbsp;dist&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;V&nbsp;=&nbsp;未被收录顶点中dist最小者&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;V==ERROR&nbsp;)&nbsp;/*&nbsp;若这样的V不存在&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;/*&nbsp;算法结束&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;将V及相应的边&lt;parent[V],&nbsp;V&gt;收录进MST&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E-&gt;V1&nbsp;=&nbsp;parent[V];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E-&gt;V2&nbsp;=&nbsp;V;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E-&gt;Weight&nbsp;=&nbsp;dist[V];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InsertEdge(&nbsp;MST,&nbsp;E&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TotalWeight&nbsp;+=&nbsp;dist[V];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist[V]&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VCount++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;W=0;&nbsp;W&lt;Graph-&gt;Nv;&nbsp;W++&nbsp;)&nbsp;/*&nbsp;对图中的每个顶点W&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dist[W]!=0&nbsp;&amp;&amp;&nbsp;Graph-&gt;G[V][W]&lt;INFINITY&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;若W是V的邻接点并且未被收录&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;Graph-&gt;G[V][W]&nbsp;&lt;&nbsp;dist[W]&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;若收录V使得dist[W]变小&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist[W]&nbsp;=&nbsp;Graph-&gt;G[V][W];&nbsp;/*&nbsp;更新dist[W]&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent[W]&nbsp;=&nbsp;V;&nbsp;/*&nbsp;更新树&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;while结束*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;VCount&nbsp;&lt;&nbsp;Graph-&gt;Nv&nbsp;)&nbsp;/*&nbsp;MST中收的顶点不到|V|个&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TotalWeight&nbsp;=&nbsp;ERROR;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TotalWeight;&nbsp;&nbsp;&nbsp;/*&nbsp;算法执行完毕，返回最小权重和或错误标记&nbsp;*/
}</pre><p style="text-indent:28px">&nbsp;</p><p><strong>8.1.4 Kruskal算法（稀疏图）—将森林合并成树</strong></p><p style="text-indent:28px">寻找权重最短的边，初始的情况下认为每一个顶点都是一棵树，通过不断把边收进来，就把两棵树并成了一棵树，最后把所有节点并成一棵树。</p><p style="text-indent:28px">伪码如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;Kruskal(Graph&nbsp;G)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MST&nbsp;=&nbsp;{};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(MST中不到|V-1|条边&amp;&amp;E中还有边){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从E中去一条权重最小的边E)(V,W);/*最小堆*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将E(V,W)从E中删除;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(E(V,W)不在MST中构成回路)/*并查集*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将E(V,W)加入MST;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;彻底无视E(V,W);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(MST中不到|V|-1条边)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERROR(&quot;生成树不存在&quot;);
}</pre><p>复杂度为T=O(|E|log|E|)</p><p style="text-indent:28px">完整代码：</p><pre class="brush:cpp;toolbar:false">/*&nbsp;邻接表存储&nbsp;-&nbsp;Kruskal最小生成树算法&nbsp;*/
&nbsp;
/*--------------------&nbsp;顶点并查集定义&nbsp;--------------------*/
typedef&nbsp;Vertex&nbsp;ElementType;&nbsp;/*&nbsp;默认元素可以用非负整数表示&nbsp;*/
typedef&nbsp;Vertex&nbsp;SetName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;默认用根结点的下标作为集合名称&nbsp;*/
typedef&nbsp;ElementType&nbsp;SetType[MaxVertexNum];&nbsp;/*&nbsp;假设集合元素下标从0开始&nbsp;*/
&nbsp;
void&nbsp;InitializeVSet(&nbsp;SetType&nbsp;S,&nbsp;int&nbsp;N&nbsp;)
{&nbsp;/*&nbsp;初始化并查集&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;X;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;X=0;&nbsp;X&lt;N;&nbsp;X++&nbsp;)&nbsp;S[X]&nbsp;=&nbsp;-1;
}
&nbsp;
void&nbsp;Union(&nbsp;SetType&nbsp;S,&nbsp;SetName&nbsp;Root1,&nbsp;SetName&nbsp;Root2&nbsp;)
{&nbsp;/*&nbsp;这里默认Root1和Root2是不同集合的根结点&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;保证小集合并入大集合&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;S[Root2]&nbsp;&lt;&nbsp;S[Root1]&nbsp;)&nbsp;{&nbsp;/*&nbsp;如果集合2比较大&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S[Root2]&nbsp;+=&nbsp;S[Root1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;集合1并入集合2&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S[Root1]&nbsp;=&nbsp;Root2;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;如果集合1比较大&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S[Root1]&nbsp;+=&nbsp;S[Root2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;集合2并入集合1&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S[Root2]&nbsp;=&nbsp;Root1;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
&nbsp;
SetName&nbsp;Find(&nbsp;SetType&nbsp;S,&nbsp;ElementType&nbsp;X&nbsp;)
{&nbsp;/*&nbsp;默认集合元素全部初始化为-1&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;S[X]&nbsp;&lt;&nbsp;0&nbsp;)&nbsp;/*&nbsp;找到集合的根&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;X;
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;S[X]&nbsp;=&nbsp;Find(&nbsp;S,&nbsp;S[X]&nbsp;);&nbsp;/*&nbsp;路径压缩&nbsp;*/
}
&nbsp;
bool&nbsp;CheckCycle(&nbsp;SetType&nbsp;VSet,&nbsp;Vertex&nbsp;V1,&nbsp;Vertex&nbsp;V2&nbsp;)
{&nbsp;/*&nbsp;检查连接V1和V2的边是否在现有的最小生成树子集中构成回路&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;Root1,&nbsp;Root2;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Root1&nbsp;=&nbsp;Find(&nbsp;VSet,&nbsp;V1&nbsp;);&nbsp;/*&nbsp;得到V1所属的连通集名称&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;Root2&nbsp;=&nbsp;Find(&nbsp;VSet,&nbsp;V2&nbsp;);&nbsp;/*&nbsp;得到V2所属的连通集名称&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;Root1==Root2&nbsp;)&nbsp;/*&nbsp;若V1和V2已经连通，则该边不能要&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;否则该边可以被收集，同时将V1和V2并入同一连通集&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Union(&nbsp;VSet,&nbsp;Root1,&nbsp;Root2&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
/*--------------------&nbsp;并查集定义结束&nbsp;--------------------*/
&nbsp;
/*--------------------&nbsp;边的最小堆定义&nbsp;--------------------*/
void&nbsp;PercDown(&nbsp;Edge&nbsp;ESet,&nbsp;int&nbsp;p,&nbsp;int&nbsp;N&nbsp;)
{&nbsp;/*&nbsp;改编代码4.24的PercDown(&nbsp;MaxHeap&nbsp;H,&nbsp;int&nbsp;p&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;/*&nbsp;将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Parent,&nbsp;Child;
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ENode&nbsp;X;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;ESet[p];&nbsp;/*&nbsp;取出根结点存放的值&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;Parent=p;&nbsp;(Parent*2+1)&lt;N;&nbsp;Parent=Child&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Child&nbsp;=&nbsp;Parent&nbsp;*&nbsp;2&nbsp;+&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;(Child!=N-1)&nbsp;&amp;&amp;&nbsp;(ESet[Child].Weight&gt;ESet[Child+1].Weight)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Child++;&nbsp;&nbsp;/*&nbsp;Child指向左右子结点的较小者&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;X.Weight&nbsp;&lt;=&nbsp;ESet[Child].Weight&nbsp;)&nbsp;break;&nbsp;/*&nbsp;找到了合适位置&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;/*&nbsp;下滤X&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESet[Parent]&nbsp;=&nbsp;ESet[Child];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ESet[Parent]&nbsp;=&nbsp;X;
}
&nbsp;
void&nbsp;InitializeESet(&nbsp;LGraph&nbsp;Graph,&nbsp;Edge&nbsp;ESet&nbsp;)
{&nbsp;/*&nbsp;将图的边存入数组ESet，并且初始化为最小堆&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;V;
&nbsp;&nbsp;&nbsp;&nbsp;PtrToAdjVNode&nbsp;W;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ECount;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;将图的边存入数组ESet&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ECount&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;V=0;&nbsp;V&lt;Graph-&gt;Nv;&nbsp;V++&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;W=Graph-&gt;G[V].FirstEdge;&nbsp;W;&nbsp;W=W-&gt;Next&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;V&nbsp;&lt;&nbsp;W-&gt;AdjV&nbsp;)&nbsp;{&nbsp;/*&nbsp;避免重复录入无向图的边，只收V1&lt;V2的边&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESet[ECount].V1&nbsp;=&nbsp;V;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESet[ECount].V2&nbsp;=&nbsp;W-&gt;AdjV;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESet[ECount++].Weight&nbsp;=&nbsp;W-&gt;Weight;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;初始化为最小堆&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;ECount=Graph-&gt;Ne/2;&nbsp;ECount&gt;=0;&nbsp;ECount--&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PercDown(&nbsp;ESet,&nbsp;ECount,&nbsp;Graph-&gt;Ne&nbsp;);
}
&nbsp;
int&nbsp;GetEdge(&nbsp;Edge&nbsp;ESet,&nbsp;int&nbsp;CurrentSize&nbsp;)
{&nbsp;/*&nbsp;给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;将最小边与当前堆的最后一个位置的边交换&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;Swap(&nbsp;&amp;ESet[0],&nbsp;&amp;ESet[CurrentSize-1]);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;将剩下的边继续调整成最小堆&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;PercDown(&nbsp;ESet,&nbsp;0,&nbsp;CurrentSize-1&nbsp;);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CurrentSize-1;&nbsp;/*&nbsp;返回最小边所在位置&nbsp;*/
}
/*--------------------&nbsp;最小堆定义结束&nbsp;--------------------*/
&nbsp;
&nbsp;
int&nbsp;Kruskal(&nbsp;LGraph&nbsp;Graph,&nbsp;LGraph&nbsp;MST&nbsp;)
{&nbsp;/*&nbsp;将最小生成树保存为邻接表存储的图MST，返回最小权重和&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;WeightType&nbsp;TotalWeight;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ECount,&nbsp;NextEdge;
&nbsp;&nbsp;&nbsp;&nbsp;SetType&nbsp;VSet;&nbsp;/*&nbsp;顶点数组&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;Edge&nbsp;ESet;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;边数组&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;InitializeVSet(&nbsp;VSet,&nbsp;Graph-&gt;Nv&nbsp;);&nbsp;/*&nbsp;初始化顶点并查集&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ESet&nbsp;=&nbsp;(Edge)malloc(&nbsp;sizeof(struct&nbsp;ENode)*Graph-&gt;Ne&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;InitializeESet(&nbsp;Graph,&nbsp;ESet&nbsp;);&nbsp;/*&nbsp;初始化边的最小堆&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;创建包含所有顶点但没有边的图。注意用邻接表版本&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;MST&nbsp;=&nbsp;CreateGraph(Graph-&gt;Nv);
&nbsp;&nbsp;&nbsp;&nbsp;TotalWeight&nbsp;=&nbsp;0;&nbsp;/*&nbsp;初始化权重和&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ECount&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;初始化收录的边数&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;NextEdge&nbsp;=&nbsp;Graph-&gt;Ne;&nbsp;/*&nbsp;原始边集的规模&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;ECount&nbsp;&lt;&nbsp;Graph-&gt;Nv-1&nbsp;)&nbsp;{&nbsp;&nbsp;/*&nbsp;当收集的边不足以构成树时&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NextEdge&nbsp;=&nbsp;GetEdge(&nbsp;ESet,&nbsp;NextEdge&nbsp;);&nbsp;/*&nbsp;从边集中得到最小边的位置&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(NextEdge&nbsp;&lt;&nbsp;0)&nbsp;/*&nbsp;边集已空&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;如果该边的加入不构成回路，即两端结点不属于同一连通集&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;CheckCycle(&nbsp;VSet,&nbsp;ESet[NextEdge].V1,&nbsp;ESet[NextEdge].V2&nbsp;)==true&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;将该边插入MST&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InsertEdge(&nbsp;MST,&nbsp;ESet+NextEdge&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TotalWeight&nbsp;+=&nbsp;ESet[NextEdge].Weight;&nbsp;/*&nbsp;累计权重&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECount++;&nbsp;/*&nbsp;生成树中边数加1&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ECount&nbsp;&lt;&nbsp;Graph-&gt;Nv-1&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TotalWeight&nbsp;=&nbsp;-1;&nbsp;/*&nbsp;设置错误标记，表示生成树不存在&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TotalWeight;
}</pre><h2>8.2 拓扑排序</h2><p><strong>8.2.1 拓扑排序</strong></p><p>AOV（Activity On Vertex）网络</p><p style="text-indent:28px">如图3所示，是指所有的真实活动是表现在顶点上的，顶点与顶点之间的有向边表现了顶点间的先后顺序。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180512/1526113216428445.jpg" title="1526113216428445.jpg" alt="3.jpg"/>&nbsp;</p><p style="text-align:center">图3</p><p style="text-indent:28px">所谓拓扑序是指：如果图中从V到W有一条有向路径，则V一定排在W之前，满足此条件的顶点序列称为一个拓扑序。获得一个拓扑序的过程就是拓扑排序。</p><p style="text-indent:28px">AOV网络如果有<strong>合理（所谓不合理是指，网络形成了一个环，那就代表着V必须在V开始之前结束，自然不合理）</strong>的拓扑序，则必定是<strong>有向无环图</strong>（Directed Acyclic Graph, DAG）。</p><p style="text-indent:28px">所谓拓扑排序，就是每一次输出没有前序顶点的顶点。</p><p style="text-indent:28px">伪码描述如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;TopSort()
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(cnt=0;cnt&lt;|V|;cnt++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;为输出的入度为0的顶点;/*简单粗暴法此步O(|V|)，总为O(|V|2)*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*聪明的算法如下文所述*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(这样的V不存在_{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error(&quot;图中有回路&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出V，或者记录V的输出序号;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(V的每个邻接点W)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indegree[W]--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">聪明的算法：随时将入度变为0的顶点放到一个容器（数组、堆栈、队列等都行）中，下一次直接从这里面直接拿数据就可以了。利用队列的新的伪码描述：</p><pre class="brush:cpp;toolbar:false">void&nbsp;TopSort()
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(图中每个顶点V){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Indegree[V]==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enqueue(V,Q);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(!IsEmpty(Q){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V=Dequeue(Q);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出V，或者记录V的输出序号;cnt++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(V的每个邻接点W)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(--Indegree[W]==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enqueue(W,Q);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cnt!=|V|)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error(&quot;图中有回路&quot;);
}</pre><p>时间复杂度T=O(|V|+|E|)</p><p style="text-indent:28px">完整代码：</p><pre class="brush:cpp;toolbar:false">/*&nbsp;邻接表存储&nbsp;-&nbsp;拓扑排序算法&nbsp;*/
&nbsp;
bool&nbsp;TopSort(&nbsp;LGraph&nbsp;Graph,&nbsp;Vertex&nbsp;TopOrder[]&nbsp;)
{&nbsp;/*&nbsp;对Graph进行拓扑排序,&nbsp;&nbsp;TopOrder[]顺序存储排序后的顶点下标&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Indegree[MaxVertexNum],&nbsp;cnt;
&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;V;
&nbsp;&nbsp;&nbsp;&nbsp;PtrToAdjVNode&nbsp;W;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue&nbsp;Q&nbsp;=&nbsp;CreateQueue(&nbsp;Graph-&gt;Nv&nbsp;);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;初始化Indegree[]&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(V=0;&nbsp;V&lt;Graph-&gt;Nv;&nbsp;V++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indegree[V]&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;遍历图，得到Indegree[]&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(V=0;&nbsp;V&lt;Graph-&gt;Nv;&nbsp;V++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(W=Graph-&gt;G[V].FirstEdge;&nbsp;W;&nbsp;W=W-&gt;Next)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indegree[W-&gt;AdjV]++;&nbsp;/*&nbsp;对有向边&lt;V,&nbsp;W-&gt;AdjV&gt;累计终点的入度&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;将所有入度为0的顶点入列&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(V=0;&nbsp;V&lt;Graph-&gt;Nv;&nbsp;V++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;Indegree[V]==0&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddQ(Q,&nbsp;V);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;下面进入拓扑排序&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;cnt&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;!IsEmpty(Q)&nbsp;){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;=&nbsp;DeleteQ(Q);&nbsp;/*&nbsp;弹出一个入度为0的顶点&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TopOrder[cnt++]&nbsp;=&nbsp;V;&nbsp;/*&nbsp;将之存为结果序列的下一个元素&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;对V的每个邻接点W-&gt;AdjV&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;W=Graph-&gt;G[V].FirstEdge;&nbsp;W;&nbsp;W=W-&gt;Next&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;--Indegree[W-&gt;AdjV]&nbsp;==&nbsp;0&nbsp;)/*&nbsp;若删除V使得W-&gt;AdjV入度为0&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddQ(Q,&nbsp;W-&gt;AdjV);&nbsp;/*&nbsp;则该顶点入列&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;while结束*/
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;cnt&nbsp;!=&nbsp;Graph-&gt;Nv&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;/*&nbsp;说明图中有回路,&nbsp;返回不成功标志&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
}</pre><p><strong>8.2.2 关键路径</strong></p><p style="text-indent:28px">AOE（Activity On Edge）网络一般用于安排项目的工序。与AOV不同，AOE的活动表示在边上，而节点代表活动到此结束。一般情况下，AOE网络的图示为以下结构：</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180512/1526113272929914.jpg" title="1526113272929914.jpg" alt="4.jpg"/>&nbsp;</p><p style="text-align:center">图4</p><p style="text-indent:28px">如图5所示，图中虚线，且权重为0表示的是，要继续执行9/7权重那里，4/5这里必须都得走到了。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180512/1526113276128244.jpg" title="1526113276128244.jpg" alt="5.jpg"/>&nbsp;</p><p style="text-align:center">图5</p><p style="text-indent:28px">问题1：整个工期有多长？</p><p style="text-indent:28px">Earliest[0]=0;</p><p style="text-indent:28px">Earliest[j]=max(&lt;i,j&gt;∈E){Earliest[i]+C&lt;i,j&gt;}</p><p style="text-indent:28px">故Earliest[8]=18</p><p style="text-indent:28px">问题2：哪几个组有机动时间（保证工期最长18天）？</p><p style="text-indent:28px">方法是设置最后一个最晚完成时间为18天，然后往前推。</p><p style="text-indent:28px">注意：虽然7倒推回去5只需要在第10天完工就可以，但是考虑到4必须在第7天完工，而6必须在第16天完工，又由于4、5同时完工才能往下走，所以5的最晚完成时间也必须和4同样，为第7天。</p><p style="text-indent:28px">Latest[8]=18;</p><p style="text-indent:28px">Latest[i]=(min&lt;i,j&gt;∈E){Latest[j]-C&lt;i,j&gt;}</p><p style="text-indent:28px">所谓机动时间就是哪些组可以不用急着赶工</p><p style="text-indent:28px">机动时间D&lt;i,j&gt;=Latest[j]-Earliest[i]-C&lt;i,j&gt;</p><p style="text-indent:28px">所谓关键路径就是整个流程中最需要关注的地方，哪些步骤是一点也不能耽误的，只要它耽误了，整个流程都要耽误，所以它是<strong><span style="color:red">绝对不允许延误的活动</span></strong>组成的路径。</p><p><br/></p>
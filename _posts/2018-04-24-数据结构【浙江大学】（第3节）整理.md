---
ID: 3756
post_title: >
  数据结构【浙江大学】（第3节）整理
post_name: '%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e3%80%90%e6%b5%99%e6%b1%9f%e5%a4%a7%e5%ad%a6%e3%80%91%ef%bc%88%e7%ac%ac3%e8%8a%82%ef%bc%89%e6%95%b4%e7%90%86'
author: 小奥
post_date: 2018-04-24 11:01:55
layout: post
link: >
  http://www.yushuai.me/2018/04/24/3756.html
published: true
tags:
  - 数据结构
categories:
  - Data Structure
---
<h1>第三讲 树（上）</h1><h2>3.1 树与树的表示</h2><p><strong>1.查找</strong></p><p style="text-indent:28px">查找是指根据某个给定关键字K，从集合R中找出关键字与K相同的记录。它分为以下两类：</p><p style="text-indent:28px">（1）静态查找：集合中记录是固定的，没有插入和删除操作。</p><p style="text-indent:28px">（2）动态查找：集合中记录是动态变化的，除了查找，还可能发生插入和删除。</p><p style="text-indent:28px">首先举一个<strong>顺序查找</strong>的例子。此例需要注意，其设置了一个哨兵，因此可以减少判断中的一个条件。这个例子要求是在Element[1]~Element[n]中查找关键字为K的数据元素，其结构体如下：</p><pre class="brush:cpp;toolbar:false">typedef&nbsp;struct&nbsp;LNode&nbsp;*List;
struct&nbsp;LNode{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;Element[MAXSIZE];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Length;
};</pre><p style="text-indent:28px">则查找算法代码如下：</p><pre class="brush:cpp;toolbar:false">int&nbsp;SequentialSearch(List&nbsp;Tb1,&nbsp;ElementType&nbsp;K)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tb1-&gt;Element[0]=K;/*建立哨兵*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i-Tb1-&gt;Length;Tb1-&gt;Element[i]!=K;i--);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;/*查找成功返回下标，不成功返回0*/
}</pre><p>时间复杂性<strong>O(n)。</strong></p><p style="text-indent:28px">再举一个<strong>二分查找</strong>的例子。二分查找遵循以下要求：假设n个数据元素的关键字满足有序，并且是连续存放。</p><p style="text-indent:28px">例如，假设有13个数据元素，按照关键字由小到大顺序存放，二分查找关键字为444的数据。</p><table><tbody><tr class="firstRow"><td width="43" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p>5</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>16</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>39</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>45</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>51</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>98</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>100</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>202</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>226</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>321</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>368</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>444</p></td><td width="43" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>501</p></td></tr></tbody></table><p style="text-indent:28px">理论步骤是如表1.1所示。</p><p style="text-align:center">表1.1 二分法步骤</p><table><tbody><tr class="firstRow"><td width="111" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p>left</p></td><td width="111" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>right</p></td><td width="111" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>mid</p></td><td width="111" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>value</p></td><td width="111" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p>comparsion</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p>1</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>13</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>7</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>100</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>100&lt;444，右侧</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p>8</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>13</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>10</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>321</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>321&lt;444，右侧</p></td></tr><tr><td width="111" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p>11</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>13</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>12</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>444</p></td><td width="111" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p>444=444，结束</p></td></tr></tbody></table><p style="text-indent:28px">程序代码如下：</p><pre class="brush:cpp;toolbar:false">int&nbsp;BinarySearch(List&nbsp;Tbl,&nbsp;ElementType&nbsp;K)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;left,&nbsp;right,&nbsp;mid,&nbsp;NoFount&nbsp;=&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;1;/*初始左侧边界*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;Tbl-&gt;Length;/*初始右侧边界*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(left&nbsp;&lt;=&nbsp;right)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;(left&nbsp;+&nbsp;right)&nbsp;/&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(K&nbsp;&lt;&nbsp;Tbl-&gt;Element[mid])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;=&nbsp;mid&nbsp;-&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(K&nbsp;&gt;&nbsp;Tbl-&gt;Element[mid])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;mid&nbsp;+&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;return&nbsp;mid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NotFound;
}</pre><p>时间复杂度是<strong>O(logN)</strong>。</p><p><strong>2.树的定义和术语</strong></p><p>树（Tree）：n（n≥0）个结点构成的有限集合。当n=0时，称为空树。</p><p style="text-indent:28px">对于任一棵非空树（n&gt;0），它具备以下性质：</p><p style="text-indent:28px">（1）树种有一个称为根的特殊结点，用r表示；</p><p style="text-indent:28px">（2）其余结点可分为m（m＞0）个互不相交的有限集T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的“子树”。</p><p style="text-indent:28px">（3）子树是不相交的；</p><p style="text-indent:28px">（4）除了根结点外，每个结点有且只有一个父节点；</p><p style="text-indent:28px">（5）一棵N个结点的树有N-1条边。</p><p style="text-indent:28px">树的一些基本术语：</p><p style="text-indent:28px">（1）结点的度：结点子树个数。</p><p style="text-indent:28px">（2）树的度：树的所有结点中最大的度数。</p><p style="text-indent:28px">（3）叶结点：度为0的结点。</p><p style="text-indent:28px">（4）父结点：有子树的结点是其子树的根结点的父结点。</p><p style="text-indent:28px">（5）子结点：若A结点是B结点的父结点，则称B结点是A结点的子结点。</p><p style="text-indent:28px">（6）兄弟结点：具有同一父结点的各结点彼此是兄弟结点。</p><p style="text-indent:28px">（7）路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…nk，其中ni是ni+1的父结点。路径所包含边的个数为路径的长度。</p><p style="text-indent:28px">（8）祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。</p><p style="text-indent:28px">（9）子孙节点：某一结点的子树中的所有结点是这个结点的子孙。</p><p style="text-indent:28px">（10）结点的层次：规定根结点在1层，其它任一结点的层数是其父结点的层数加1。</p><p style="text-indent:28px">（11）树的深度：树种所有结点总的最大层次是这棵树的深度。</p><p><strong>3.树的表示</strong></p><p>&nbsp;&nbsp; &nbsp;数组、链表都是很难表示树的，因为树的结构是多变的，无法统一规定。因此在这里用“<strong>儿子-兄弟表示法</strong>”，结构如下面所示。</p><table><tbody><tr class="firstRow"><td colspan="2" valign="top" style="border-width: 1px;border-color: windowtext;padding: 0 7px"><p style="text-align:center">Element</p></td></tr><tr><td valign="top" style="border-right-width: 1px;border-bottom-width: 1px;border-left-width: 1px;border-right-color: windowtext;border-bottom-color: windowtext;border-left-color: windowtext;border-top: none;padding: 0 7px"><p style="text-align:center">FirstChild</p></td><td valign="top" style="border-top: none;border-left: none;border-bottom-width: 1px;border-bottom-color: windowtext;border-right-width: 1px;border-right-color: windowtext;padding: 0 7px"><p style="text-align:center">NextSibling</p></td></tr></tbody></table><p style="text-indent:28px">如图1左所示的树结构可以表示为图1右所示的表示法。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180424/1524538762128265.jpg" title="1524538762128265.jpg" alt="1524538762128265.jpg" width="323" height="147"/></p><p style="text-align:center">图1</p><p style="text-indent:28px">把这个树往右转向45°，可以看出，这是一个度为2的树。这种方法也被称为——<strong><span style="color:red">二叉树</span></strong>。</p><h2>3.2 二叉树</h2><p><strong>1.二叉树的定义</strong></p><p>&nbsp;&nbsp;&nbsp; 二叉树T：一个有穷的结点集合。这个集合可以为空。若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。</p><p style="text-indent:28px">二叉树的五种基本形态如图2所示，几种特殊二叉树如图3所示。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180424/1524538779384852.jpg" title="1524538779384852.jpg" alt="1524538779384852.jpg" width="435" height="101"/>&nbsp;</p><p style="text-align:center">图2</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180424/1524538792735225.jpg" title="1524538792735225.jpg" alt="1524538792735225.jpg" width="467" height="283"/>&nbsp;</p><p style="text-align:center">图3</p><p style="text-indent:28px">对完全二叉树左一个说明。完全二叉树可以是满二叉树缺少最低一层最右侧几个，只要前面都对的起来即可，但是<strong><span style="color:red">绝不能在中间缺几个（如图3右下角）</span></strong>。</p><p><strong>2.二叉树的几个重要性质</strong></p><p style="text-indent:28px">（1）一个二叉树第i层的最大结点数为：2<sup>i-1</sup>，i≥1。</p><p style="text-indent:28px">（2）深度为k的二叉树最大节点数是2<sup>k</sup>-1，k≥1。</p><p style="text-indent:28px">（3）对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点个数，那么两者满足n0=n2+1。</p><p><strong>3.二叉树的抽象数据类型定义</strong></p><p>类型名称：二叉树</p><p>数据对象集：一个有穷的结点集合。若不为空，则由根结点和其左、右二叉子树组成。</p><p>操作集：BT∈BinTree，Item∈ElementType，重要的操作有：</p><p>&nbsp;&nbsp;&nbsp; （1）Boolean IsEmpty(BinTree BT)：判断BT是否为空；</p><p style="text-indent:28px">（2）void Traversal(BinTree BT)：遍历，按某顺序访问每个结点；</p><p style="text-indent:28px">（3）BinTree CreatBinTree()：创建一个二叉树。</p><p style="text-indent:28px">二叉树常用的便利方法有：</p><p style="text-indent:28px">（1）void PreOrderTraversal(BinTree BT)：先序——根、左子树、右子树；</p><p style="text-indent:28px">（2）void InOrderTraversal(BinTree BT)：中序——左子树、根、右子树；</p><p style="text-indent:28px">（3）void PostOrderTraversal(BinTree BT)：后序：左子树、右子树、根；</p><p style="text-indent:28px">（4）void LevelOrderTraversal(BinTree BT)：层次遍历：从上到下、从左到右。</p><p><strong>4.二叉树的存储结构</strong></p><p style="text-indent:28px">（1）顺序存储结构</p><p style="text-indent:28px">完全二叉树：按从上至下、从左到右顺序存储，n个结点的完全二叉树的结点父子关系，可以使用顺序存储结果。如图4所示。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180424/1524538808162249.jpg" title="1524538808162249.jpg" alt="4.jpg"/></p><p style="text-align:center">图4</p><p style="text-indent:28px">这个完全二叉树很有规律，很容易找到其父结点和子结点。我们可以发现：</p><p style="text-indent:28px">①非根节点（序号i&gt;1）的父结点的序号是[i/2]（在这里[]表示取整）；</p><p style="text-indent:28px">②结点（序号为i）的左孩子结点序号为2i（若2i&gt;=n，就没有左孩子）；</p><p style="text-indent:28px">③结点（序号为i）的右孩子结点序号为2i+1（若2i+1&gt;=n，就没有右孩子）。</p><p style="text-indent:28px">推广来说，一般二叉树也可以采用这种结构，方法就是通过补空位使其变成完全二叉树。但这样的结果是会造成空间浪费。</p><p style="text-indent:28px">（2）链表存储</p><p style="text-indent:28px">一般二叉树的结点可以用下面的方式表示：</p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-color: windowtext;padding: 0 7px"><p style="text-align:center">Left</p></td><td valign="top" style="border-top-width: 1px;border-right-width: 1px;border-bottom-width: 1px;border-top-color: windowtext;border-right-color: windowtext;border-bottom-color: windowtext;border-left: none;padding: 0 7px"><p style="text-align:center">Data</p></td><td valign="top" style="border-top-width: 1px;border-right-width: 1px;border-bottom-width: 1px;border-top-color: windowtext;border-right-color: windowtext;border-bottom-color: windowtext;border-left: none;padding: 0 7px"><p style="text-align:center">Right</p></td></tr></tbody></table><p style="text-indent:28px">其代码表示如下：</p><pre class="brush:cpp;toolbar:false">typedef&nbsp;struct&nbsp;TreeNode&nbsp;*BinTree;
typedef&nbsp;BinTree&nbsp;Position:
struct&nbsp;TreeNode{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;Data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BinTree&nbsp;Left;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BinTree&nbsp;Right;
};</pre><p><strong>5.二叉树的递归遍历</strong></p><p style="text-indent:28px">（1）先序遍历</p><p style="text-indent:28px">遍历过程为：</p><p style="text-indent:28px">①访问根结点；②先序遍历其左子树，先序遍历其右子树。</p><p style="text-indent:28px">程序如下所示：</p><pre class="brush:cpp;toolbar:false">void&nbsp;PreOrderTraversal(BinTree&nbsp;BT)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(BT){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&quot;,BT-&gt;Data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreOrderTraversal(BT-&gt;Left);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreOrderTraversal(BT-&gt;Right);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">（2）中序遍历</p><p style="text-indent:28px">遍历过程为：</p><p style="text-indent:28px">①中序遍历其左子树；②访问根结点；③中序遍历其右子树。</p><p style="text-indent:28px">程序如下所示：</p><pre class="brush:cpp;toolbar:false">void&nbsp;InOrderTraversal(BinTree&nbsp;BT)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(BT){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreOrderTraversal(BT-&gt;Left);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&quot;,BT-&gt;Data);
PreOrderTraversal(BT-&gt;Right);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">（3）后序遍历</p><p style="text-indent:28px">便利过程：</p><p style="text-indent:28px">①后续遍历其左子树；②后续遍历其右子树；③访问根结点。</p><p style="text-indent:28px">代码如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;PostOrderTraversal(BinTree&nbsp;BT)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(BT){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreOrderTraversal(BT-&gt;Left);
PreOrderTraversal(BT-&gt;Right)
printf(&quot;%d&quot;,BT-&gt;Data);;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><strong>6.二叉树的非递归遍历（以中序为例）</strong></p><p style="text-indent:28px">基本思路：<strong><span style="color:#4472C4">使用堆栈</span></strong>。</p><p style="text-indent:28px">如图5所示的二叉树，我们以此未来来介绍利用堆栈进行处理的方法，输出顺序为：DBEFAGHCI。处理的方法见表3.1所示。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180424/1524538820783938.jpg" title="1524538820783938.jpg" alt="5.jpg"/>&nbsp;</p><p style="text-align:center">图5</p><p style="text-align:center">表3.1 使用堆栈算法的表格示意</p><table><tbody><tr class="firstRow"><td width="47" valign="top" style="border-width: 1px; border-color: windowtext; padding: 0px 7px;"><p style="text-align:center">序号</p></td><td width="50" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p style="text-align:center">当前结点</p></td><td width="150" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p style="text-align:center">堆栈（从左到右相当于从底到顶）</p></td><td width="204" valign="top" style="border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-left: none; padding: 0px 7px;"><p style="text-align:center">步骤说明</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">1</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">A</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[A]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">首先把A压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">2</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">B</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[AB]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">B为A的左孩子，压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">3</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">D</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[ABD]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">D为B的左孩子，压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">4</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[AB]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">D无孩子，将D推出堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">5</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[A]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">将<strong>B推出堆栈</strong></p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">6</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">F</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[AF]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">由于F为B右孩子，在B推出时将F压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">7</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">E</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[AFE]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">E为F左孩子，压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">8</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[AF]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">E无孩子，将<strong>E推出堆栈</strong></p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">9</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[A]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center"><strong>将F推出堆栈</strong></p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">10</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center"><strong>将A推出堆栈</strong></p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">11</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">C</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[C]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">将G压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">12</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">G</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[CG]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">G为C的左孩子，压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">13</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[C]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">G没有左孩子，<strong>G推出堆栈</strong></p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">14</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">H</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[CH]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">将G的右孩子压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">15</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[C]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">H无孩子，<strong>H推出堆栈</strong></p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">16</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">&nbsp;[]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center"><strong>将C推出堆栈</strong></p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">17</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">I</p></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[I]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">将I压入堆栈</p></td></tr><tr><td width="47" valign="top" style="border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-top: none; padding: 0px 7px;"><p style="text-align:center">18</p></td><td width="50" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><br/></td><td width="150" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center">[]</p></td><td width="204" valign="top" style="border-top: none; border-left: none; border-bottom-width: 1px; border-bottom-color: windowtext; border-right-width: 1px; border-right-color: windowtext; padding: 0px 7px;"><p style="text-align:center"><strong>将I推出堆栈</strong></p></td></tr></tbody></table><p style="text-indent:28px">具体执行代码如下：</p><pre class="brush:cpp;toolbar:false">void&nbsp;InOrderTraversal(BinTree&nbsp;BT)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BinTree&nbsp;T=BT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack&nbsp;S=CreatStack(MaxSize);/*创建并初始化堆栈S*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(T||!IsEmpty(S)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(T)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{/*一致向左将沿途结点压入堆栈*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Push(S,T);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T=T-&gt;Left;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!IsEmpty(S))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T=&nbsp;Pop(S);/*结点弹出堆栈*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%5d&quot;,,T-&gt;Data);/*打印结点*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T=T-&gt;Right;/*转向右子树*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p style="text-indent:28px">同理可得，中序遍历为：</p><pre class="brush:cpp;toolbar:false">void&nbsp;PreOrderTraversal(BinTree&nbsp;BT)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BinTree&nbsp;T=BT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack&nbsp;S=CreatStack(MaxSize);/*创建并初始化堆栈S*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(T||!IsEmpty(S)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(T)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{/*一致向左将沿途结点压入堆栈*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%5d&quot;,,T-&gt;Data);/*打印结点*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Push(S,T);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T=T-&gt;Left;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!IsEmpty(S))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T=&nbsp;Pop(S);/*结点弹出堆栈*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T=T-&gt;Right;/*转向右子树*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><strong>7.层序遍历</strong></p><p style="text-indent:28px">层次遍历是利用队列的方式进行。遍历从根结点开始，首先将根结点指针入队，然后开始执行下面三个操作：</p><p style="text-indent:28px">（1）从队列中取出一个元素；</p><p style="text-indent:28px">（2）访问该元素所指结点；</p><p style="text-indent:28px">（3）若钙元素所指结点的左、右孩子结点费控，则将其左、右孩子的指针顺序入队。</p><p style="text-indent:28px">不断执行这三步操作，直到队列为空，再无元素可取，二叉树的层序遍历就完成了。其代码如下所示：</p><pre class="brush:cpp;toolbar:false">void&nbsp;LevelOrderTraversal(BinTree&nbsp;BT)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BinTree&nbsp;T;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue&nbsp;Q;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!BT)&nbsp;return;/*空树直接返回*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;=&nbsp;CreatQueue(MaxSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddQ(Q,BT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(!IsEmptyQ(Q)){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;=&nbsp;DeleteQ(Q);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d\n&quot;,T-&gt;Data);&nbsp;/*访问取出队列的结点*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(T-&gt;Left)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddQ(Q,T-&gt;Left);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(T-&gt;Right)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddQ(Q,T-&gt;Right);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><strong>8.遍历应用的例子</strong></p><p>【例1】遍历二叉树的应用：输出二叉树中的叶子结点。</p><pre class="brush:cpp;toolbar:false">void&nbsp;PreOrderTraversal(BinTree&nbsp;BT)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(BT){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!BT-&gt;Left&nbsp;&amp;&amp;!BT-&gt;Right)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d&quot;,BT-&gt;Data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreOrderTraversal(BT-&gt;Left);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreOrderTraversal(BT-&gt;Right);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>【例2】求二叉树的高度。</p><pre class="brush:cpp;toolbar:false">int&nbsp;PostOrderGetHeight(BinTree&nbsp;BT)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;HL,HR,MaxH;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(BT){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HL&nbsp;=&nbsp;PostOrderGetHeight(BT-&gt;Left);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HR&nbsp;=&nbsp;PostOrderGetHeight(BT-&gt;Right);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxH&nbsp;=&nbsp;(HL&gt;HR)?HL:HR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;MaxH+1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;return&nbsp;0;
}</pre><p>【例3】二元运算表达式树及其遍历</p><p style="text-indent:28px">如图6所示。</p><p style="text-indent: 0em; text-align: center;"><img src="/wp-content/uploads/image/20180424/1524538879168912.jpg" title="1524538879168912.jpg" alt="6.jpg"/></p><p style="text-indent: 0em; text-align: center;">图6</p><p style="text-indent:28px">三种遍历可以得到三种不同的访问结果：</p><p style="text-indent:28px">（1）中序遍历得到中缀表达式：a + b * c + d * e + f * g</p><p style="text-indent:28px">（2）先序遍历得到前缀表达式：+ + a * b c * + * d e f g</p><p style="text-indent:28px">（3）后序遍历得到后缀表达式：a b c * + d e * f + g * +</p><p style="text-indent:28px">由此直接将表达式存入链表就可以了。</p><p>【例4】由两种遍历序列确定二叉树：已知三种遍历中的<strong><span style="color:#4472C4">任意两种</span></strong>遍历序列，能否<strong><span style="color:#4472C4">唯一确定</span></strong>一棵二叉树呢？</p><p style="text-indent:28px">只需要确保其中一个是<strong><span style="color:red">中序遍历</span></strong>，就可以唯一确定。如果只有前序遍历、后序遍历，这就不可能找到唯一的。</p><p style="text-indent:28px">下面以先序和中序遍历序列来确定一棵二叉树。</p><p style="text-indent:28px">先序遍历序列的第一个结点就是根结点。这个根结点能够在中序遍历序列中将其余结点分割成两个子序列，根结点前面部分是左子树上的结点，而根结点后面的部分是右子树上的结点。</p><p style="text-indent:28px">根据这两个子序列，在先序序列中找到对应的左子序列和右子序列，它们分别对应左子树和右子树。</p><p style="text-indent:28px">然后对左子树和右子树分别递归使用相同的方法继续分解。</p><p><strong>9.二叉树的创建</strong></p><p>&nbsp;&nbsp;&nbsp; 由于树是非线性结构，创建一棵二叉树必须首先确定树种结点的输入顺序，常用的方法是<strong>先序创建</strong>和<strong>层序创建</strong>两种。</p><p><br/></p>
---
ID: 3692
post_title: >
  吴恩达深度学习课程DeepLearning.ai笔记（5-2）
post_name: '%e5%90%b4%e6%81%a9%e8%be%be%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e8%af%be%e7%a8%8bdeeplearning-ai%e7%ac%94%e8%ae%b0%ef%bc%885-2%ef%bc%89'
author: 小奥
post_date: 2018-03-18 20:52:37
layout: post
link: >
  http://www.yushuai.me/2018/03/18/3692.html
published: true
tags:
  - 人工智能
  - 神经网络
categories:
  - Deep Learning
---
<h1>Project 5 Week3 自然语言处理与词汇嵌入</h1><h2>1 词汇表征</h2><p>1. One-hot表征</p><p style="text-indent:28px">one-hot表征的方式是对模型字典中的单词进行表征，对应单词的位置用1表示，其余位置用0表示，如图1所示：</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180318/1521377082123595.jpg" title="1521377082123595.jpg" alt="1521377082123595.jpg" width="356" height="266"/></p><p style="text-align:center">图1</p><p style="text-indent:28px">这种方法是存在缺点的，它将每个词孤立起来，使得模型对相关词的泛化能力不强，每个词向量之间的距离都一样，乘积均为0，所以无法获取词与词之间的相似性和关联性。</p><p>2.特征表征：词嵌入</p><p style="text-indent:28px">这种方法是用不同的特征来对词汇进行表示，不同的单词在不同的特征下都有不同的取值，取值可以表示该词汇在该特征下的相似度情况，如图2所示，Man与Woman在Gender特征上是完全不相通，而在其它属性上相似。Man和King，Woman和Queen在Gender上相似，说明他们具有一定的相关性，其它以此类推。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180318/1521377105124317.jpg" title="1521377105124317.jpg" alt="1521377105124317.jpg" width="579" height="277"/>&nbsp;</p><p style="text-align:center">图2</p><p style="text-indent:28px">利用这种表征方法，词汇之间的相似度很容易得到体现，这样对于不同单词，模型的返回性能会好很多。我们利用t-SNE算法将N维词向量映射到2维空间，如图3所示，可以看出相似的词汇总是聚集在一起。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180318/1521377134392676.jpg" title="1521377134392676.jpg" alt="1521377134392676.jpg" width="320" height="247"/>&nbsp;</p><p style="text-align:center">图3</p><h2>2 词汇嵌入</h2><h3>2.1 使用词嵌入</h3><p><strong>名字实体识别的例子：</strong></p><p style="text-indent:28px">如下面的一个句子中名字实体的定位识别问题，假如我们有一个比较小的数据集，可能不包含durain（榴莲）和cultivator（培育家）这样的词汇，那么我们就很难从包含这两个词汇的句子中识别名字实体。但是如果我们从网上的其他地方获取了一个学习好的词汇嵌入，它将告诉我们榴莲是一种水果，并且培育家和农民相似，那么我们就有可能从我们少量的训练集中，归纳出没有见过的词汇中的名字实体。</p><p><strong>Sally&nbsp;&nbsp;&nbsp;&nbsp; Johnson is an orange farmer.</strong></p><p><strong>Robert&nbsp;&nbsp;&nbsp; Lin&nbsp;&nbsp; &nbsp;&nbsp;is a&nbsp; durian&nbsp; cultivator.</strong></p><p><strong>词嵌入的迁移学习：</strong></p><p>有了词嵌入，就可以让我们能够使用迁移学习，通过网上大量的无标签的文本中学习到的知识，应用到我们少量文本训练集的任务中。下面是做词嵌入迁移学习的步骤：</p><p>&nbsp;</p><p>第一步：从大量的文本集合中学习词汇嵌入（1-100B words），或者从网上下载预训练好的词嵌入模型；</p><p>第二步：将词嵌入模型迁移到我们小训练集的新任务上；</p><p>第三步：可选，使用我们新的标记数据对词嵌入模型继续进行微调。</p><h3>2.2 词嵌入特性</h3><p>1.类比推理特性</p><p style="text-indent:28px">词嵌入可以帮助实现类比推理。如图2所示，通过不同词向量之间的相见计算，可以发现不同词汇之间的类比关系。例如：e<sub>man</sub>-e<sub>woman</sub>=[-2,0,0,0]（后三项非常小，近似于0）。</p><p style="text-indent:28px">计算词与词之间的相似度，实际上是在多维空间中，寻找词向量之间各个维度的距离相似度。</p><p style="text-indent:28px">例如，我们寻找一个与king相似于man-woman关系的词汇，实际上相当于寻找下面这两个向量之间的最大相似度，如式（2.1）所示。</p><p style="text-indent:28px">同时我们引入了相似度函数，如式2.2所示。</p><p style="text-indent: 0em; text-align: center;"><img src="/wp-content/uploads/image/20180318/1521377171674207.jpg" title="1521377171674207.jpg" alt="1521377171674207.jpg" width="245" height="71"/></p><h3>2.3 嵌入矩阵</h3><p style="text-indent:28px">在我们要对一个词汇表学习词汇嵌入模型时，实质上就是要学习这个词汇表对应的一个嵌入矩阵E。当我们学习好了这样一个嵌入矩阵后，通过嵌入矩阵与对应词的one-hot向量相乘，则可得到该词汇的嵌入，如下图所示：</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180318/1521377249136306.jpg" title="1521377249136306.jpg" alt="1521377249136306.jpg" width="485" height="238"/></p><p style="text-align: center;">图4</p><p><strong>注意：在实际中，总是利用一些特殊的函数来寻找一种嵌入。</strong></p><h3>2.4 学习词嵌入</h3><p><strong>早期的学习算法：</strong></p><p><strong>【参考文献：Bengio et.al.,2013, A neural probabilistic language model】</strong></p><p>如下面的例子中，我们要通过前面几个单词，预测最后一个单词：</p><p>（1）通过将每个单词的one-hot向量与嵌入矩阵相乘，得到相应的词汇嵌入；</p><p>（2）利用窗口函数控制影响预测结果的单词数量，并将窗口内词汇嵌入堆叠起来输入到神经网络中；</p><p>（3）最后通过softmax层输出整个词汇表各个单词可能的概率。</p><p style="text-indent:28px">其中，隐藏层和softmax层都有自己的参数，假设词汇表的大小为(10000)，每个单词的Embedding大小是(300)，历史窗口大小为44，那么输入的大小即为(300*4=1200)，softmax输出大小为词汇表大小(10000)。整个模型的参数就是嵌入矩阵E，以及隐藏层和softmax层的参数w[1],b[1],w[2],b[2]。可以利用反向传播算法进行梯度下降，来最大化训练集似然函数，不断地从语料库中预测最后一个词的输出。</p><p style="text-indent:28px">在不断地训练过程中，算法会发现要想最好地拟合训练集，就要使得一些特性相似的词汇具有相似的特征向量，从而就得到了最后的词嵌入矩阵E。</p><p><strong>其他的上下文和目标词对：</strong></p><p>我们将要预测的单词称为目标词，其是通过一些上下文推导预测出来的。对于不同的问题，上下文的大小和长度以及选择的方法有所不同：</p><p>（1）选取目标词之前的几个词；</p><p>（2）选取目标词前后的几个词；</p><p>（3）选取目标词前的一个词；</p><p>（4）选取目标词附近的一个词，（一种Skip-Gram模型的思想）。</p><h2>3 Word2Vec</h2><p><strong>【参考文献：Mikolov et. al., 2013. Efficient estimation of word representations in vector space】</strong></p><p><strong>Skip-grams：</strong></p><p style="text-indent:28px">在这个模型中，我们需要抽取上下文（Content）和目标词汇（Target）来配对构造一个监督学习问题。</p><p style="text-indent:28px">注意，上下文不一定是要目标词前后离得最近的几个单词，而是随机选择一个词作为上下文，同时在上下文的一定距离范围内随机选择另外一个词作为目标词。构造这样一个监督学习问题的目的并不是为了解决监督学习问题本身，而是想要这个问题来学习一个更好的词汇嵌入模型。</p><p><strong>Model：</strong></p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180318/1521377303135712.jpg" title="1521377303135712.jpg" alt="1521377303135712.jpg" width="364" height="158"/></p><p style="text-align:center">图5</p><p><strong>存在的问题：</strong>计算速度的问题，如在上面的SoftmaxSoftmax单元中，我们需要对所有10000个整个词汇表的词做求和计算，计算量庞大。</p><p><strong>简化方案：</strong>使用分级softmax分类器（相当于一个树型分类器，每个节点都是可能是一个二分类器），其计算复杂度是前面的log|v|级别。在构造分级softmax分类器时，一般常用的词会放在树的顶部位置，而不常用的词则会放在树的更深处，其并不是一个平衡的二叉树。</p><p><strong>如何采样上下文：</strong></p><p style="text-indent:28px">在构建上下文目标词对时，如何选择上下文与模型有不同的影响。</p><p style="text-indent:28px">对语料库均匀且随机地采样：使得如the、of、a等这样的一些词会出现的相当频繁，导致上下文和目标词对经常出现这类词汇，但我们想要的目标词却很少出现。</p><p style="text-indent:28px">采用不同的启发来平衡常见和不常见的词进行采样。这种方法是实际使用的方法。</p><h2>4 负采样</h2><p><strong>【参考文献：Mikolov et. al., Distributed representation of words and phrases and their compositionality】</strong></p><p><strong>新的学习问题：</strong></p><p style="text-indent:28px">定义一个新的学习问题：预测两个词之间是否是上下文-目标词对，如果是词对，则学习的目标为1；否则为0。</p><p style="text-indent:28px">使用k次相同的上下文，随机选择不同的目标词，并对相应的词对进行正负样本的标记，生成训练集。</p><p style="text-indent:28px">建议：小数据集，k=5~20；大数据集，k=2~5。</p><p style="text-indent:28px">最后学习x——y的映射关系。</p><p style="text-indent:28px">如图6所示。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180318/1521377325105172.jpg" title="1521377325105172.jpg" alt="1521377325105172.jpg" width="479" height="230"/>&nbsp;</p><p style="text-align:center">图6</p><p style="text-indent:28px">在负采样模型中，我们使用logistic回归模型：</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180318/1521377206113090.jpg" title="1521377206113090.jpg" alt="1521377206113090.jpg" width="200" height="30"/></p><p style="text-indent:28px">每个正样本均有k个对应的负样本。在训练的过程中，对于每个上下文词，我们就有对应的k+1个分类器。如下图所示。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180318/1521377360263785.jpg" title="1521377360263785.jpg" alt="1521377360263785.jpg" width="579" height="308"/></p><p style="text-align:center">图7</p><p style="text-indent:28px">相比与Skip-grams模型，负采样不再使用一个具有词汇表大小时间复杂度高的庞大维度的Softmax，而是将其转换为词汇表大小个二分类问题。每个二分类任务都很容易解决，因为每个的训练样本均是1个正样本，外加k个负样本。</p><p><strong>如何选择负样本：</strong></p><p style="text-indent:28px">在选定了上下文（Content）后，在确定正样本的情况下，我们还需要选择k个负样本以训练每个上下文的分类器。</p><p style="text-indent:28px">通过单词出现的频率进行采样：导致一些类似a、the、of等词的频率较高；</p><p style="text-indent:28px">均匀随机地抽取负样本：没有很好的代表性；</p><p style="text-indent:28px">还有一种方法是处于上面两种极端采样方法之间，即不用频率分布，也不用均匀分布，而采用的是对词频的3/4除以词频3/4整体的和进行采样的。其中，f(wj)是语料库中观察到的某个词的词频，公示如下所示：</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180318/1521377392119188.jpg" title="1521377392119188.jpg" alt="function3.jpg"/></p><h2>5 Glove词向量</h2><p><strong>【参考文献：Pennington et. al., 2014. GloVe:Global vectors for word representation】</strong></p><p style="text-indent:28px">GloVe（global vectors for word representation）词向量模型是另外一种计算词嵌入的方法，虽然相比下没有Skip-grams模型用的多，但是相比这种模型却更加简单。</p><p style="text-indent:28px">GloVe词向量模型中，要定义一个量X<sub>ij</sub>，表示目标词ii出现在上下文j的次数。模型的优化目标如下：</p><p style="text-indent: 0em; text-align: center;"><img src="/wp-content/uploads/image/20180318/1521377408339354.jpg" title="1521377408339354.jpg" alt="1521377408339354.jpg" width="345" height="47"/></p><p><strong><span style="color:red">注意：</span></strong></p><p style="text-indent:28px">因为当Xij为0时，logXij没有意义，所以增加一个f(Xij)的加权项，当Xij=0时，f(Xij)=0，另外f(Xij)对于一些频繁词和不频繁词有着启发式的平衡作用；</p><p style="text-indent:28px">另外，ΘTiej这一项中，ΘTi和ej都是需要学习的参数，在这个目标算法中二者是对称的关系，所以我们可以一致地初始化Θ和e，然后用梯度下降来最小化输出，在处理完所有词后，直接取二者的平均值作为词嵌入向量。这与前面的算法有所不同。</p><p><strong>词嵌入的特征化：</strong></p><p style="text-indent:28px">通过上面的很多算法得到的词嵌入向量，我们无法保证词嵌入向量的每个独立分量是能够让我们理解的。我们能够确定是每个分量是和我们所想的一些特征是有关联的，其可能是一些我们能够理解的特征的组合而构成的一个组合分量。使用上面的GloVe模型，从线性代数的角度解释如下：</p><p style="text-align:center"><strong><img src="/wp-content/uploads/image/20180318/1521377479115269.jpg" title="1521377479115269.jpg" alt="1521377479115269.jpg" width="298" height="30"/></strong></p><p style="text-indent:28px">加入的A项，可能构成任意的分量组合。</p><h2>6 情绪分类</h2><p style="text-indent:28px">情感分类就是通过一段文本来判断这个文本中的内容是否喜欢其所讨论的内容，这是NLP中最重要的模块之一。</p><p style="text-indent:28px">情感分类任务存在的一个问题就是只有很小的数据集，缺乏训练样本。但是在使用了词嵌入后，则能够带来很好的效果，足以训练一个良好的情感分类模型。</p><p><strong>平均值或和的模型：</strong></p><p style="text-indent:28px">获取一个训练好的词嵌入矩阵E；</p><p style="text-indent:28px">得到每个词的词嵌入向量，并对所有的词向量做平均或者求和；</p><p style="text-indent:28px">输入到softmax分类器中，得到最后的输出y^；</p><p style="text-indent:28px">缺点：没有考虑词序，可能会导致多数的积极词汇削弱前面消极词汇的影响，从而造成错误的预测。</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180318/1521377493315265.jpg" title="1521377493315265.jpg" alt="1521377493315265.jpg" width="579" height="326"/></p><p style="text-align:center">图8</p><p><strong>RNN模型：</strong></p><p>获取一个训练好的词嵌入矩阵E；</p><p>得到每个词的词嵌入向量，输入到many-to-one的RNN模型中；</p><p>通过最后的softmax分类器，得到最后的输出y^。</p><p>优点：考虑了词序，效果好很多。</p><p style="text-align:center"><img src="/wp-content/uploads/image/20180318/1521377520183034.jpg" title="1521377520183034.jpg" alt="1521377520183034.jpg" width="579" height="326"/>&nbsp;</p><p style="text-align:center">图9</p><h2>7 词嵌入除偏</h2><p><strong>【参考文献：Bolukbasi et. al., 2016. Man is to computer programmer as woman is to homemaker? Debiasing word embeddings】</strong></p><p style="text-indent:28px">当下机器学习或者人工智能算法已经被应用到做一些非常重要的决策中，因此我们需要尽可能地保证其不受非预期形式的偏见的影响，如性别、种族歧视等等。下面介绍一些在词嵌入中消除偏见的办法。</p><p>目前的偏见问题：</p><p style="text-indent:28px">以一些预料库中学习到的词嵌入向量，会发现学习到的词向量存在下面一些具有性别、种族等偏见，这反映了人们在历史的写作中存在的这种社会偏见：</p><p style="text-align:center">&nbsp;<img src="/wp-content/uploads/image/20180318/1521377539578214.jpg" title="1521377539578214.jpg" alt="1521377539578214.jpg" width="390" height="168"/></p><p style="text-align:center">图10</p><p><strong>消除偏见的方法</strong>：</p><p>1.定义偏见的方向：如性别</p><p>（1）对大量性别相对的词汇进行相减并求平均；</p><p>（2）通过平均后的向量，则可以得到一个或多个偏见趋势相关的维度，以及大量不相关的维度。</p><p>2.中和化：对每一个定义不明确的词汇，进行偏见的处理，如像doctor、babysitter这类词；通过减小这些词汇在得到的偏见趋势维度上值的大小。</p><p>3.均衡：将如gradmother和gradfather这种对称词对调整至babysitter这类词汇平衡的位置上，使babysitter这类词汇处于一个中立的位置，进而消除偏见。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong><span style="font-size:14px;font-family:等线;color:#7F7F7F"></span></strong></p><p><strong><span style="color:#7F7F7F">部分内容参考自<a href="http://blog.csdn.net/koala_tree/article/details/79440375"><span style="color:#7F7F7F">http://blog.csdn.net/koala_tree/article/details/79440375</span></a>，在此对原作者表示感谢。</span></strong></p><p><strong><span style="color:#7F7F7F"></span></strong><br/></p><p><strong><span style="font-size:14px;font-family:等线;color:#7F7F7F"></span></strong><br/></p>